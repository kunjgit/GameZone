<html lang="en">
	<head>
		<meta charset="UTF-8">
		<title>Immunity Collapse</title>
		<style>
			body {
				margin:0;
				overflow:hidden;
				font-family:Arial;
			}
			#c {
				position:absolute;
				top:0;
				left:0;
			}
		</style>
		

	<script id="vsSource" type="x-shader/x-vertex">
		precision mediump int;
		precision highp float;
	
		attribute vec4 aVertexPosition;
		uniform mat4 uModelViewMatrix;
		uniform mat4 uProjectionMatrix;
		uniform float uRadius;
		uniform int uType;
		uniform float iTime;
		uniform float meRadius;
		uniform float collid;
		uniform float uvBack;
		uniform float fade;
		
		varying vec4 vColor;
		void main() {
			gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
			vColor = aVertexPosition;
		}
	</script>
		
	<script id="fsSource" type="x-shader/x-fragment">
		// Fragment shader program
		precision mediump int;
		precision highp float;
		
		varying vec4 vColor;
		uniform float uRadius;
		uniform int uType;
		uniform float iTime;
		uniform float meRadius;
		uniform float collid;
		uniform float uvBack;
		uniform float fade;
		
		const float dihedIcos = 0.364863828;
		const float pentaHeight = 1.5*acos(dot(normalize(vec3(1.6180339+1., 1., 1.6180339)), normalize(vec3(.5))));
		
		vec2 Rot2D (vec2 q, float a) {return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);}
		
		vec4 qmult(vec4 p, vec4 q) {
			vec3 pv = p.xyz;
			vec3 qv = q.xyz;
			return vec4(
				p.w * qv + q.w * pv + cross(pv, qv),
				p.w * q.w - dot(pv, qv)
			);
		}
		
		vec3 rotate(vec3 point, vec4 qrotor) {
			vec3 rv = qrotor.xyz;
			return qmult(qrotor, vec4(point * qrotor.w - cross(point, rv), dot(point, rv))).xyz;
		}
		
		float sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {
			vec3 pa = p - a, ba = b - a;
			float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
			return length( pa - ba*h ) - r;
		}
		
		float opUnion( float d1, float d2, float k ) {
			float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );
			return mix( d2, d1, h ) - k*h*(1.0-h);
		}
		

		
	
	//
	// CELL
	//
	
	float smin( float a, float b, float k ) {
		float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
		return mix( b, a, h ) - k*h*(1.0-h);
	}
	
	float fbm(vec2 uv) {
		float f = 200.0;
		vec2 tmp;
		float T = 100.0 + iTime * 0.3;
		T += sin(iTime * 4.0) * .1 + cos(iTime) * .15;
		// layers of cells with some scaling and rotation applied.
		for (int i = 1; i < 8; ++i) {
			uv.y -= T * .5;
			uv.x -= T * .4;
			tmp = uv;
			
			uv.x = tmp.x * .9 - tmp.y * .45; 
			uv.y = tmp.x * .45 + tmp.y * .9; 
			
			vec2 uv2 = mix(sin(uv + vec2(1.57, 0)), sin(uv.yx*1.4 + vec2(1.57, 0)), .75);
			f = smin(f, uv2.x*uv2.y*.3 + .7, .07);
			
		}
		return 1. - f;
	}
	
	
	



	// BACKGROUND

float rand(vec2 co){
	return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}



// Rough Value noise implementation
float valueNoiseSimple(vec2 vl) {
	float minStep = 1.0 ;

	vec2 grid = floor(vl);
	vec2 gridPnt1 = grid;
	vec2 gridPnt2 = vec2(grid.x, grid.y + minStep);
	vec2 gridPnt3 = vec2(grid.x + minStep, grid.y);
	vec2 gridPnt4 = vec2(gridPnt3.x, gridPnt2.y);

	float s = rand(grid);
	float t = rand(gridPnt3);
	float u = rand(gridPnt2);
	float v = rand(gridPnt4);

	float x1 = smoothstep(0., 1., fract(vl.x));
	float interpX1 = mix(s, t, x1);
	float interpX2 = mix(u, v, x1);

	float y = smoothstep(0., 1., fract(vl.y));
	float interpY = mix(interpX1, interpX2, y);

	return interpY;
}



float fractalNoise(vec2 vl) {
	float amplitude = .5;
	float rez = 0.;

	for (float i = 0.0; i < 8.0; i++) {
		rez += amplitude * valueNoiseSimple(vl);
		amplitude /= 2.;
		vl *= 2.;
	}
	return rez;
}

float complexFBM(vec2 p) {
	float slow = iTime / 20.;
	float fast = iTime / 2.05;
	vec2 offset1 = vec2(cos(slow) + slow  , 0.); // Main front
	vec2 offset2 =vec2(sin(fast ), 0.); // sub fronts

	return fractalNoise(p + offset1 + fractalNoise(
	    	p + fractalNoise(
			p + 2. * fractalNoise(p - offset2)
	    	)
	));
}

		void main() {
			vec2 iResolution = vec2(uRadius*2.0, uRadius*2.0);
			vec2 fragCoord = vColor.xy;
			vec2 pc = vColor.xy * 2.0;
			if (uType==2) { //BACKGROUND BLOOD
				vec2 uv = fragCoord.xy / iResolution.xy-0.5;
				vec3 color2 = vec3(0.3, 0., 0.05);
				vec3 color1 = vec3(0.);
				vec3 rez = mix(color1, color2, complexFBM(uv*uvBack));  //40

				gl_FragColor = vec4(rez, 1.0);
				
				float mult = 40.0;
				float dist;
				dist = abs((uv.x+0.5)*2.0);
				if (dist>0.5) {
					gl_FragColor.rgb*= max(0., 0.55 - dist)*mult;
					mult /= 2.0;
				}
				dist = abs((uv.y+0.5)*2.0);
				if (dist>0.5) {
					gl_FragColor.rgb*= max(0., 0.55 - dist)*mult;
				}
			} else if (uType==0) { //CELL 
				float distance = length(vColor.xy);
				vec2 uv = fragCoord.xy / iResolution.xy;
				uv.y /= iResolution.x / iResolution.y;
				vec2 ouv = uv;
				float B = sin(iTime * 4.0 + uRadius);
				uv = mix(uv, uv * sin(B), .035);
				vec2 _uv = uv * 25.;
				float f = fbm(_uv);

				if (distance>uRadius) {
					gl_FragColor.a = 0.0;
				} else {
					gl_FragColor.a = 1.0;

					vec2 off = vec2(0.0, .03);
					gl_FragColor.rgb = mix(vec3(1.*f,(.3 + B * .05)*f,(0.1 + B * .05)*f) + pow(max(0., dot(normalize(cross(vec3(.0025, f - fbm(_uv + off.yx), 0.), -vec3(0, f - fbm(_uv + off), .0025))).xzy, normalize(normalize(vec3(uv, 1.))))), 4.) * .2 * vec3(.4, .7, .7), vec3(0.), smoothstep(.45, .55, (max(abs(ouv.y * iResolution.x / iResolution.y), abs(ouv.x)))));

					// contrast
					gl_FragColor = smoothstep(.0, 1., gl_FragColor);


					//
					// Crop en forme de cercle et colors en fonction de la taille
					//
					float fadeLength = uRadius*0.25;

					if (distance>(uRadius-fadeLength) && distance<uRadius) {
						float a = 1.-((distance-(uRadius-fadeLength)) / fadeLength);

						if (a>0.5) { // Premiere partie en fondu au noir
							gl_FragColor.rgb*= (a*2.0)-1.0; 
							gl_FragColor.a = 1.0;
						} else {
							float f = abs(a-0.5);
							if (uRadius>meRadius) {
								gl_FragColor.rgba = mix(vec4(1.,.0,.0,1.),vec4(1.,.0,.0,.5), f*4.);
							} else {
								gl_FragColor.rgba = mix(vec4(1.), vec4(1.,1.,1.,.5), f*4.);
							}
						}
					}
				}
			} else { // VIRUS
				fragCoord.x+= uRadius;
				fragCoord.y+= uRadius;
				
				vec4 rotY = vec4(vec3(0., sin(iTime*0.5), 0.), cos(iTime*0.5));
				vec4 rotX = vec4(vec3(sin(iTime*0.5), 0., 0.), cos(iTime*0.5));
				vec4 dirA = qmult(rotY, rotX);
				vec3 dir = rotate(normalize(vec3((2. * fragCoord - iResolution.xy) / iResolution.y, -2.35)), dirA);
				
				vec3 camera = rotate(vec3(0., 0., 1.7748), dirA);
				
				float dist, t = 0.;
				vec4 col;
				float maxDist = 0.;
				float alpha = 0.;
				vec3 pos;
				float l = length(camera)-.5;
				for(float i = 0.; i < 100.; i++) {
					pos = camera + t * dir;
					
					vec3 p = pos;
					p.x = 32.0 * (fract(p.x / 32.0 - .5) - .5);
					
					float a, w;
					w = 2.09;
					p.z = abs (p.z);
					p.yz = Rot2D (p.yz, - dihedIcos);
					p.x = - abs (p.x);
					for (int k = 0; k < 4; k ++) {
						p.zy = Rot2D (p.zy, - dihedIcos);
						p.y = - abs (p.y);
						p.zy = Rot2D (p.zy, dihedIcos);
						if (k < 3) p.xy = Rot2D (p.xy, - w);
					}
					p.z = - p.z;
					a = mod (atan (p.x, p.y) + .5 * w, w) - .5 * w;
					p.yx = vec2 (cos (a), sin (a)) * length (p.xy);
					p.x -= 2. * p.x * step (0., p.x);
					
					p.yz = Rot2D (p.yz, -dihedIcos);
					float d = length(vec3(p.x, p.y, p.z + .65)) - .045;
					float d2 = sdCapsule(p,  vec3(0), vec3(0., 0., -.65), .02);
					p.xz = Rot2D (p.xz, pentaHeight);
					d = min(d, length(vec3(p.x, p.y, p.z + .60)) - .045);
					d2 = min(d2, sdCapsule(p,  vec3(0), vec3(0., 0., -.60), .02));

					d = min(d, length(p)-.45); //Sphere centrale
					float h = clamp( .5 + .5*(d-d2)/.05, .0, 1. );
					d = mix( d, d2, h ) - .05*h*(1.-h);
					
					d = max(d, -length(p)+.40);
					dist = d;
					
					col.rgb += pow(.002/max(0., dist + .065), 1.1)
						* pow(1. - (t - l) / 2.5, 6.)
						* mix(
							vec3(collid, .03, 10. - (10. * collid)), 
							vec3(.005, 1.-collid ,.01), 
							length(pos)
						);

					if (dist<0. && alpha<=0.1) {
						alpha = 1.;
					}
					t += max(.001, dist);
					if(t > 2.5) break;
					maxDist = max(maxDist, dist);
				}
				col.a = alpha;
				gl_FragColor = col;
			}
			gl_FragColor.rgb=mix(vec3(0.0),gl_FragColor.rgb,fade);
		}
	</script>
	</head>
	<body>
		<canvas id="glCanvas" width="1900" height="800"></canvas>
		<canvas id="c" width="1900" height="800"></canvas>
		
<script>
glCanvas.style.width = "100%";
glCanvas.style.height = "100%";
c.style.width = "100%";
c.style.height = "100%";		

//
// Méthodes 3D
//									
glMatrixArrayType="undefined"!=typeof Float32Array?Float32Array:"undefined"!=typeof WebGLFloatArray?WebGLFloatArray:Array;
var mat44={};
mat44.create=function(r){var t = new glMatrixArrayType(16);t[0] = t[5] = t[10] = t[15] = 1;return t;};
mat44.translate=function(out,a ,v){var x = v[0],y = v[1],z = v[2];var a00,a01,a02,a03,a10,a11,a12,a13,a20,a21,a22,a23;if(a===out){out[12]=a[0]*x+a[4]*y+a[8]*z+a[12];out[13]=a[1]*x+a[5]*y+a[9]*z+a[13];out[14]=a[2]*x+a[6]*y+a[10]*z+a[14];out[15]=a[3]*x+a[7]*y+a[11]*z+a[15];}else{a00=a[0];a01=a[1];a02=a[2];a03=a[3];a10=a[4];a11=a[5];a12=a[6];a13=a[7];a20=a[8];a21=a[9];a22=a[10];a23=a[11];out[0]=a00;out[1]=a01;out[2]=a02;out[3]=a03;out[4]=a10;out[5]=a11;out[6]=a12;out[7]=a13;out[8]=a20;out[9]=a21;out[10]=a22;out[11]=a23;out[12]=a00*x+a10*y+a20*z+a[12];out[13]=a01*x+a11*y+a21*z+a[13];out[14]=a02*x+a12*y+a22*z+a[14];out[15]=a03*x+a13*y+a23*z+a[15];}return out;};
mat44.rotate=function(r,t,a,n){var e=a[0],u=a[1];a=a[2];var i=Math.sqrt(e*e+u*u+a*a);if(!i)return null;1!=i&&(e*=i=1/i,u*=i,a*=i);var o=Math.sin(t),f=Math.cos(t),m=1-f;t=r[0],i=r[1];var c=r[2],v=r[3],y=r[4],l=r[5],s=r[6],M=r[7],p=r[8],A=r[9],d=r[10],h=r[11],F=e*e*m+f,g=u*e*m+a*o,x=a*e*m-u*o,T=e*u*m-a*o,b=u*u*m+f,w=a*u*m+e*o,G=e*a*m+u*o;return e=u*a*m-e*o,u=a*a*m+f,n?r!=n&&(n[12]=r[12],n[13]=r[13],n[14]=r[14],n[15]=r[15]):n=r,n[0]=t*F+y*g+p*x,n[1]=i*F+l*g+A*x,n[2]=c*F+s*g+d*x,n[3]=v*F+M*g+h*x,n[4]=t*T+y*b+p*w,n[5]=i*T+l*b+A*w,n[6]=c*T+s*b+d*w,n[7]=v*T+M*b+h*w,n[8]=t*G+y*e+p*u,n[9]=i*G+l*e+A*u,n[10]=c*G+s*e+d*u,n[11]=v*G+M*e+h*u,n};
mat44.perspective=function(out,fovy,aspect,near,far){var f =1.0/Math.tan(fovy/2);out[0]=f/aspect;out[1]=0;out[2]=0;out[3]=0;out[4]=0;out[5]=f;out[6]=0;out[7]=0;out[8]=0;out[9]=0;out[11]=-1;out[12]=0;out[13]=0;out[15]=0;if(far!=null && far!==Infinity){var nf=1/(near-far);out[10]=(far+near)*nf;out[14]=2*far*near*nf;}else{out[10]=-1;out[14]=-2*near;}return out;};


GOOD = 0;
ME = 1;
BACKGROUND = 2;
var muted = false;

var speed = 1;
var extraDecal={x:0,y:0};
class CELL {
	constructor(type, x, y, radius, vX, vY) {
		this.x = x;
		this.y = y;
		this.radius = radius;
		this.setVelocity(vX ? vX : 0, vY ? vY : 0);
		
		this.type=type;
		this.collid = false;
		this.collidPercent = 0.0;
		this.contacts = [];
	}
	setVelocity(x, y) {
		this.velocity = {
			x:x,
			y:y,
			speed:Math.hypot(x, y)
		};
	}
	update() {
		if (this.radius<0) {
			return false;
		}
		this.x+=this.velocity.x * (speed/(16.66/nbMs));
		this.y+=this.velocity.y * (speed/(16.66/nbMs));
		
		//Gère les rebons sur les bords
		if (this.x-this.radius<0) {
			this.x = this.radius * 2 - this.x;
			this.velocity.x = -this.velocity.x;
		}
		if (this.y-this.radius<0) {
			this.y = this.radius * 2 - this.y;
			this.velocity.y = -this.velocity.y;
		}
		if (this.x+this.radius>stage.width) {
			this.x = -2*this.radius + 2*stage.width - this.x;
			this.velocity.x = -this.velocity.x;
		}
		if (this.y+this.radius>stage.height) {
			this.y = -2*this.radius + 2*stage.height - this.y;
			this.velocity.y = -this.velocity.y;
		}
	}
	impulse(x, y) {
		playNote(12, song.tracks[3].instrument, 0.45);
		this.setVelocity(this.velocity.x+x/10, this.velocity.y+y/10);
		
		// Il faut calculer la surface de la projection
		// Puis déduire cette surface de l'aire actuel
		var S = Math.PI * (this.radius*this.radius);
		var projection = S*0.025;
		
		this.radius = Math.sqrt(S*0.95 / Math.PI); //FIXME, quand on est gros c'est beaucoup trop
		var impulseRadius = Math.sqrt(projection / Math.PI);
		
		//Créer un nouvel élément du même type que moi dans le sens inverse
		stage.elements.push(new CELL(
			this.type,
			this.x-((this.radius+impulseRadius)*x)*1.1,
			this.y-((this.radius+impulseRadius)*y)*1.1,
			impulseRadius,
			-x+this.velocity.x, //-x/100.0,
			-y+this.velocity.y, //-y/100.0
		));
	}
}
class STAGE {
	constructor(width, height) {
		this.width = width;
		this.height = height;
		this.elements = [];
		this.elements.push(new CELL(BACKGROUND,this.width/2,this.height/2,Math.max(this.width, this.height)));
		this.goal = "";
		this.ended = false;
	}
	checkGoal() {
		switch (this.goal) {
			case "onlyVirus": //Seulement des virus
				var onlyVirus = true;
				for (var i=1; i<this.elements.length; i++) {
					if (this.elements[i].type!=ME) {
						onlyVirus = false;
						break;
					}
				}
				return onlyVirus;
				break;
			case "getAll": //Être le seul
				if (this.elements.length==2 && !me.isDied) {
					return true;
				}
				break;
			case "bigest": //Le plus gros
				var maxRadius = 0;
				for (var i=1; i<this.elements.length; i++) {
					if (this.elements[i].type!=ME) {
						maxRadius = Math.max(maxRadius, this.elements[i].radius);
					}
				}
				if (me.radius>maxRadius) {
					return true;
				}
				break;
		}
		return false;
	}
}

rand = function(min, max) {
	return (Math.random()*(max-min)) + min;
};
window.onresize = function() {
	initCamera();
};
var stage, background;
var me;
var gl;
var programInfo;
var buffers;
var projectionMatrix = mat44.create();
var fieldOfView = 45 * Math.PI / 180;
var ratioText;
var uvBack = 40;
var ctx2D = c.getContext("2d");
var unitInPx;
var vFOV = 45 * Math.PI / 180;        // convert vertical fov to radians
var maxZoom;
var oldDT=0;
var nbMs = 16;
var level = -1;
var tuto=[];
var tutoLeft;

var heightHUD = 198;
var mouse = {
	pressed:false,
	x:0,
	y:0
};
var minY, maxY;
var frameStart;
var levelStart = false;
var homeLoaded = 0;

initCamera = function() {
	c.height = document.body.clientHeight;
	c.width = document.body.clientWidth;
	
	ratioText = c.width/1920;
	
	minY = document.body.clientHeight/2 - heightHUD/2 - 30;
	maxY = document.body.clientHeight/2 + heightHUD/2 + 10;

	projectionMatrix = mat44.create();
	mat44.perspective(
		projectionMatrix,
		fieldOfView,
		gl.canvas.clientWidth / gl.canvas.clientHeight,
		0.1,
		10000.0
	);
};


/**
 * Creates a pseudo-random value generator. The seed must be an integer.
 *
 * Uses an optimized version of the Park-Miller PRNG.
 * http://www.firstpr.com.au/dsp/rand31/
 */
function Random(seed) {
	this._seed = seed % 2147483647;
	if (this._seed <= 0) this._seed += 2147483646;
};

/**
 * Returns a pseudo-random value between 1 and 2^32 - 2.
 */
Random.prototype.next = function () {
	return this._seed = this._seed * 16807 % 2147483647;
};

/**
 * Returns a pseudo-random floating point number in range [0, 1).
 */
Random.prototype.nextFloat = function () {
	// We know that result of next() will be 1 to 2147483646 (inclusive).
	return (this.next() - 1) / 2147483646;
};


init = function() {
	const canvas = document.querySelector('#glcanvas');
	gl = canvas.getContext('webgl');
	
	gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque
	gl.clearDepth(1.0);                 // Clear everything
	gl.enable(gl.DEPTH_TEST);           // Enable depth testing
	gl.depthFunc(gl.LEQUAL);            // Near things obscure far things

	gl.enable(gl.BLEND);
	gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

	const shaderProgram = initShaderProgram(gl, document.getElementById('vsSource').innerText, document.getElementById('fsSource').innerText);
	programInfo = {
		program: shaderProgram,
		attribLocations: {
			vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
		},
		uniformLocations: {
			projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
			modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
			radius: gl.getUniformLocation(shaderProgram, 'uRadius'),
			type: gl.getUniformLocation(shaderProgram, 'uType'),
			iTime: gl.getUniformLocation(shaderProgram, 'iTime'),
			meRadius: gl.getUniformLocation(shaderProgram, 'meRadius'),
			collid: gl.getUniformLocation(shaderProgram, 'collid'),
			uvBack:gl.getUniformLocation(shaderProgram, 'uvBack'),
			fade:gl.getUniformLocation(shaderProgram, 'fade')
			
		}
	};

	initLevel(-1);

	// Draw the scene
	drawScene(gl, programInfo, buffers);
	initCamera();
};


drawTuto = function() {
	if (tuto.length==0) { return; }
	var t = tuto[0];
	if (t.t) {
		//Ecrire le texte : Exécuté à chaque frame
		drawText(
			c.width/2 - ((12*(t.t.length*1.5*(c.width/1920))/2)), 
			c.height - (6*12*1.5*(c.width/1920)), 
			t.t, 
			1.5*(c.width/1920)
		);
	
		var text = "CLICK TO CONTINUE";
		drawText(
			c.width/2 - ((12*(text.length*1.0*(c.width/1920))/2)), 
			c.height - (3*12*1.0*(c.width/1920)), 
			text, 
			1.0*(c.width/1920),
			false,
			"#888"
		);
	}
	
	if (typeof(t.z)!="undefined") { //Zoom sur : Executé une seul fois
		targetextraDecal.x = stage.elements[t.z].x - stage.elements[1].x;
		targetextraDecal.y = stage.elements[t.z].y - stage.elements[1].y;
		if (t.z==0) {
			targetZoom = maxZoom;
		}
		delete t.z;
	}
	if (t.a) { //Action : Executé une seul fois
		SHOW_TARGET = true;
		delete t.a;
	}
};

tutoNext = function() {
	tuto.splice(0,1);
	if (tuto.length==0) {
		levelStart = true;
		SHOW_TARGET = true;
	}
};

fadeToLevel = function(level) {
	//initLevel(level);
	fade.inProgress = true;
	fade.out = 1;
	fade.level = level;
}


initLevel = function(l, rand) {
	mouse.over = false;
	extraDecal = {x:0,y:0};
	targetextraDecal = {x:0, y:0};

	zoom = targetZoom = -100;
	level = l;
	SHOW_TARGET = false;
	levelStart = false;
	uvBack = 40;
	tuto = [];
	switch (level) {
		case -1: //Home
			stage = new STAGE(800,600);
			me = new CELL(ME, 400, 300, 5);
			targetZoom = -100;
			break;
		case 0: //Main menu
			stage = new STAGE(800,600);
			me = new CELL(ME, 400, 300, 5);
			targetZoom = -100;
			break;
		case 1:
			uvBack = 10;
			stage = new STAGE(200,200);
			stage.goal = "onlyVirus";
			me = new CELL(ME, 50, 100, 10);
			targetZoom = -40;
			tuto = [
				{t:"THAT IS YOU, A VIRUS", z:1},
				{t:"THIS IS A RED BLOOD CELL", z:2},
				{t:"YOUR GOAL ? ABSORD IT", z:0},
				{t:"MOVE YOUR MOUSE AROUND YOU AND CLICK TO IMPULSE", z:0, a:true}
			];
			stage.elements.push(new CELL(GOOD,150,100,8));
			break;
		case 2:
			uvBack = 10;
			stage = new STAGE(200,200);
			stage.goal = "onlyVirus";
			me = new CELL(ME, 50, 100, 10);
			targetZoom = -100;
			tuto = [
				{t:"YOU CAN ONLY ABSORB CELLS IF THEY ARE SMALLER THAN YOU", z:0},
				{t:"IF YOU TOUCH A CELL BIGGER THAN YOU ? DEATH...", z:0},
				{t:"THE CELLS SURROUNDED BY WHITE ARE SMALLER. OF RED, BIGGER", z:0},
			];
			stage.elements.push(new CELL(GOOD,150,100,10.25));
			stage.elements.push(new CELL(GOOD,100,50,6));
			stage.elements.push(new CELL(GOOD,100,150,6));
			break;
		case 3:
			rand = 1;
			levelRand = new Random(rand);
			stage = new STAGE(800,800);
			stage.goal = "bigest";
			tuto = [
				{t:"SPEED UP THE TIME OR SLOW IT DOWN WITH THE LEFT PANEL FOR MORE PRECISION", z:1},
			];

			me = new CELL(ME,400,400,5);
			for (var i=0; i<600; i++) {
				var radius = 1+(levelRand.nextFloat()*10);
				var x = radius/2 + (levelRand.nextFloat()*(stage.width-radius/2));
				var y = radius/2 + (levelRand.nextFloat()*(stage.height-radius/2));
				stage.elements.push(new CELL(GOOD,x,y,radius,(levelRand.nextFloat()*0.02) - 0.01,(levelRand.nextFloat()*0.02) - 0.01));
			}
			break;
		case 4:
			rand = 56;
			levelStart = true;
			SHOW_TARGET = true;
			levelRand = new Random(rand);
			stage = new STAGE(800,800);
			stage.goal = "bigest";
			
			me = new CELL(ME,400,300,5);
			for (var i=0; i<600; i++) {
				var radius = 1+(levelRand.nextFloat()*12);
				var x = radius/2 + (levelRand.nextFloat()*(stage.width-radius/2));
				var y = radius/2 + (levelRand.nextFloat()*(stage.height-radius/2));
				stage.elements.push(new CELL(GOOD,x,y,radius,));
			}
			
			stage.elements.push(new CELL(GOOD,390,265,30));
			stage.elements.push(new CELL(GOOD,415,330,20));
			stage.elements.push(new CELL(GOOD,370,325,20));
			stage.elements.push(new CELL(GOOD,430,280,10));
			break;
		case 5:
			if (!rand) {
				rand = 1;
			}
			levelStart = true;
			SHOW_TARGET = true;
			levelRand = new Random(rand);
			stage = new STAGE(800,800);
			stage.goal = "bigest";
			
			me = new CELL(ME,400,300,5);
			for (var i=0; i<600; i++) {
				var radius = 1+(levelRand.nextFloat()*12);
				var x = radius/2 + (levelRand.nextFloat()*(stage.width-radius/2));
				var y = radius/2 + (levelRand.nextFloat()*(stage.height-radius/2));
				stage.elements.push(new CELL(GOOD,x,y,radius,levelRand.nextFloat()/8.0,levelRand.nextFloat()/8.0));
			}
			break;
		case 6:
		case 7:
			rand = Math.floor(Math.random()*10000);
			levelStart = true;
			SHOW_TARGET = true;
			levelRand = new Random(rand);
			stage = new STAGE(800,800);
			stage.goal = "bigest";
			
			me = new CELL(ME,400,300,5);
			for (var i=0; i<600; i++) {
				var radius = 1+(levelRand.nextFloat()*12);
				var collidWithMe = true;
				while (collidWithMe) {
					var x = radius/2 + (levelRand.nextFloat()*(stage.width-radius/2));
					var y = radius/2 + (levelRand.nextFloat()*(stage.height-radius/2));
					if (Math.hypot(x-me.x, y-me.y)>radius*2.0) {
						collidWithMe = false;
					}
				}
				
				stage.elements.push(new CELL(GOOD,x,y,radius,level==6 ? 0 : (levelRand.nextFloat()/8.0)-0.0625,level==6 ? 0 : (levelRand.nextFloat()/8.0)-0.0625));
			}
			break;
	}
	me.isDied = false;
	stage.elements.push(me);
	tutoLeft = tuto.length;
	if (tutoLeft) {
		SHOW_TARGET = false;
	}
};

init();
window.addEventListener("wheel", event => {
	var speedDelta = 1+((Math.sign(event.deltaY))/10);
	targetZoom*= speedDelta;
	return false;
});

document.onmousemove = function(e) {
	c.style.cursor = "default";
	
	mouse.x = e.clientX;
	mouse.y = e.clientY;
	
	if (e.clientX>13 && e.clientX<32 && e.clientY>minY && e.clientY<minY+20) {
		c.style.cursor = "pointer";
	} else if (e.clientX>13 && e.clientX<32 && e.clientY>maxY && e.clientY<maxY+20) {
		c.style.cursor = "pointer";
	}
};

document.onmousedown = function(e) {
	if (level==-1) {
		initLevel(0);
		context.resume();
		frameStart = frame;
		requestAnimationFrame(playSong);
		return;
	}
	if (level==0 && homeLoaded<0.97) {
		homeLoaded = 1;
		return;
	}
	if (mouse.over) {
		ctx2D.globalAlpha = 1;
		fadeToLevel(mouse.over);
		
		return;
	}
	if (e.clientX>13 && e.clientX<32 && e.clientY>minY && e.clientY<minY+20) {
		speed = speed>0.5 ? speed/2 : speed;
	} else if (e.clientX>13 && e.clientX<32 && e.clientY>maxY && e.clientY<maxY+20) {
		speed = speed<2.0 ? speed*2 : speed;
	} else {
		mouse.pressed = true;
		mouse.pressedFrame = 0;
	}
};
document.onmouseup = function() {
	mouse.pressed = false;
};
document.onkeydown = function(e) {
	switch(e.keyCode) {
		case 77:
			muted= !muted;
			if (!muted) {
				timeStart=-1;
			}
			break;
		case 82:
			initLevel(level);
			break;
		case 27:
			fadeToLevel(0);
			break;
		default:
			return true;
			break;
	}
	return false;
};
var levelStart = false;
var homeLoaded = 0;
var fade = {
	inProgress:false,
	out:0,
	in:0,
	level:0
};
gameLoop = function(dt) {
	window.requestAnimationFrame(gameLoop);
	nbMs = dt-oldDT;
	frame+=(speed/(16.66/nbMs));
	oldDT = dt;
	
	drawScene(gl, programInfo, buffers);
	var oldMeRadius = me.radius;
	
	for (i=1; i<stage.elements.length; i++) {
		if (!stage.elements[i].radius) {
			continue;
		}
		stage.elements[i].update();
		stage.elements[i].collid = false;
	}
	unitInPx = 2 * Math.tan( vFOV / 2 ) * (-zoom);
	unitInPx= c.height / unitInPx;
	
	ctx2D.clearRect(0,0,c.width,c.height);
	ctx2D.strokeStyle = '#FFF';
	
	if (fade.inProgress) {
		if (fade.out) {
			fade.out-=0.025/(16.66/nbMs); 
			if (fade.out<=0) {
				fade.out = 0;
				initLevel(fade.level);
				fade.in = 1;
			} else {
				ctx2D.globalAlpha = fade.out;
			}
		} else if (fade.in) {
			fade.in-=0.025/(16.66/nbMs);
			if (fade.in<=0) {
				fade.inProgress = false;
				ctx2D.globalAlpha = 1;
			} else {
				ctx2D.globalAlpha = 1-fade.in;
			}
		}
	}

	
	
	if (level==-1) {
		ctx2D.globalAlpha = Math.max(0,Math.min(1.0, frame/360));
		drawText(
			c.width/2 - ((12*(14*1*(c.width/1920))/2)), 
			c.height/2 - 7, 
			"CLICK TO ENTER", 
			Math.max(0.8,1*(c.width/1920))
		);
		ctx2D.globalAlpha = 1;
		return;
	} else if (level==0) {
		mouse.over = null;
		c.style.cursor = "default";
		var text = "IMMUNITY COLLAPSE";
		for (var i=0; i<text.length; i++) {
			if (!fade.inProgress) {
				ctx2D.globalAlpha = Math.max(homeLoaded, Math.max(0,Math.min(1.0, (frame - frameStart - (6*i))/120)));
			}
			drawText(
				c.width/2 - ((12*(17*5*(c.width/1920))/2)), 
				c.height/8, 
				text[i].padStart(i+1," "), 
				5*(c.width/1920), 
				true,
				"#DDD"
			);
		}
		
		if (!fade.inProgress) {
			ctx2D.globalAlpha = Math.max(homeLoaded ? 0.5 : 0, Math.max(0,Math.min(0.5, (frame - frameStart - 180)/180)));
		} else {
			ctx2D.globalAlpha /=2;
		}
		drawText(
			c.width/2 - ((12*(29*2*(c.width/1920))/2)), 
			c.height/8 + (12*9), 
			"- THE ART OF KILLING SLOWLY - ", 
			2*(c.width/1920), 
			true,
			"#DCB",
			"#FFF"
		);
		if (fade.inProgress) {
			ctx2D.globalAlpha *=2;
		}


		var globalOpacity = Math.max(homeLoaded, Math.max(0,Math.min(1, (frame - frameStart - 300)/180)));
		if (!fade.inProgress) {
			ctx2D.globalAlpha = globalOpacity;
		}
		homeLoaded = globalOpacity;
		for (var i=0; i<7; i++) {
			var y =  c.height/8 + (20*9)+(i*c.height/20);
			if (i>1) {
				y+=c.height/20;
			}
			if (i>4) {
				y+=c.height/20;
			}
			var co = "#DDD";
			if (mouse.x > c.width/2 - ((12*(9*1.5*(c.height/1000))/2))) {
				if (mouse.x < c.width/2 + ((12*(9*1.5*(c.height/1000))/2))) {
					if (mouse.y > y) {
						if (mouse.y < y + (c.height/40)) {
							var co = "#F33";
							c.style.cursor = "pointer";
							mouse.over = i+1;
						}
					}
				}
			}
			
			var text = "";
			switch (i) {
				case 0:
					text = "TUTO 1";
					break;
				case 1:
					text = "TUTO 2";
					break;
				case 2:
					text = "EASY";
					break;
				case 3:
					text = "MEDIUM";
					break;
				case 4:
					text = "HARD";
					break;
				case 5:
					text = "RANDOM (MEDIUM)";
					break;
				case 6:
					text = "RANDOM (HARD)";
					break;
				
			}
			
			drawText(c.width/2 - ((12*(text.length*1.5*(c.height/1000))/2)), 
				y, 
				text, 
				1.5*(c.height/1000),
				false,
				co
			);
		}
		
		if (!fade.inProgress) {
			ctx2D.globalAlpha = 1;
		}

		return;
	}
	
	var angle = Math.atan2(
		mouse.y - extraDecal.y*unitInPx - (document.body.clientHeight/2), 
		mouse.x - extraDecal.x*unitInPx - (document.body.clientWidth/2)
	) - Math.PI;
	
	
	//
	// Calcule le zoom minimum
	//
	
	//Ok ça calcule le maxZoom pour voir 80 de large
	tmp = stage.width;
	if (c.width<c.height) {
		tmp/= c.width/c.height;
	}
	maxZoom = -(tmp/Math.tan( vFOV / 2 ))/2;
	
	if (levelStart) {
		var delta = 0;
		if (c.width/unitInPx<stage.width) {
			delta = stage.width - c.width/unitInPx;
		}
		if (me.x < stage.width/2 - delta) {
			extraDecal.x = me.x - (stage.width/2 - delta);
		} else if (me.x>stage.width/2+delta) {
			extraDecal.x = me.x-(stage.width/2+delta);
		}

		var delta = 0;
		if (c.height/unitInPx<stage.width) {
			delta = stage.width - c.height/unitInPx;
		}
		if (me.y < stage.width/2 - delta) {
			extraDecal.y = me.y - (stage.width/2 - delta);
		} else if (me.y>stage.width/2+delta) {
			extraDecal.y = me.y-(stage.width/2+delta);
		}
	} else {
		drawTuto();
		
		extraDecal.x+= (targetextraDecal.x - extraDecal.x)*0.05/(16.66/nbMs);
		extraDecal.y+= (targetextraDecal.y - extraDecal.y)*0.05/(16.66/nbMs);
		
		if (mouse.pressed) {
			tutoNext();
			mouse.pressed = false;
		}
	}
	
	// Dessine le viseur
	if ((!levelStart && SHOW_TARGET) || (levelStart && (!me.isDied && !stage.ended))) {
		ctx2D.save();
		ctx2D.translate(c.width/2 + extraDecal.x*unitInPx,c.height/2 + extraDecal.y*unitInPx);
		ctx2D.rotate(angle-Math.PI);
		ctx2D.beginPath();
		ctx2D.lineWidth = 2;

		var decalX = me.radius*1.2*unitInPx;
		ctx2D.moveTo(0+decalX,0);
		ctx2D.lineTo(40+decalX, 0);
		ctx2D.stroke();

		ctx2D.moveTo(40+decalX,-10);
		ctx2D.lineTo(50+decalX, -20);
		ctx2D.stroke();

		ctx2D.moveTo(40+decalX,10);
		ctx2D.lineTo(50+decalX, 20);
		ctx2D.stroke();
		ctx2D.restore();
	}
	
	if (levelStart) {
		// Dessine le HUD
		switch (stage.goal) {
			case "bigest":
				drawText(
					c.width/2 - ((12*(20*1.0*(c.width/1920))/2)), 
					30, 
					"GOAL : BE THE BIGGEST", 
					1.0*(c.width/1920),
				);
				break;
			case "onlyVirus":
				drawText(
					c.width/2 - ((12*(23*1.0*(c.width/1920))/2)), 
					30, 
					"GOAL : ABSORB ALL CELLS", 
					1.0*(c.width/1920),
				);
				break;
		}
		 
		// Zone de taille
		if (level>=3) {
			var bigest=0;
			for (var i=2; i<stage.elements.length; i++) {
				bigest = Math.max(bigest, stage.elements[i].radius);
			}
			var xHUD = document.body.clientWidth/2 - heightHUD/2;
			ctx2D.strokeRect(xHUD,10, heightHUD+2, 10);

			var r = 1/bigest*me.radius;
			var pos = r*(heightHUD-20);

			ctx2D.fillStyle = 'hsl('+ (180-(180*r)) +',50%,50%)';
			ctx2D.fillRect(xHUD+1+pos, 11, 20, 8);
		
			//Zone de vitesse
			var yHUD = document.body.clientHeight/2 - heightHUD/2;
			ctx2D.strokeRect(10,yHUD, 20, heightHUD+2);

			var r = ((globalDetune/200)+1)/2;
			var pos = r*(heightHUD-20);

			ctx2D.fillStyle = 'hsl('+ (180-(180*r)) +',50%,50%)';
			ctx2D.fillRect(11,yHUD+1+pos, 18, 20);

			// + et -
			ctx2D.beginPath();
			ctx2D.strokeRect(10,yHUD-30, 20, 20);
			ctx2D.strokeRect(10,yHUD+heightHUD+11, 20, 20);

			ctx2D.moveTo(15, yHUD-20);
			ctx2D.lineTo(25, yHUD-20);
			ctx2D.moveTo(15, yHUD+heightHUD+20);
			ctx2D.lineTo(25, yHUD+heightHUD+20);
			ctx2D.moveTo(20, yHUD+heightHUD+15);
			ctx2D.lineTo(20, yHUD+heightHUD+25);
			ctx2D.stroke();
		}
		drawText(c.width - (12*12), 
			12, 
			"ESC - MENU&R - RETRY&M - MUTE", 1);

		if (stage.ended) {
			var text = "CONGRATULATIONS&   - CLICK -";
			drawText(
				c.width/2 - ((12*(15*1.5*(c.width/1920))/2)), 
				c.height - (6*12*1.5*(c.width/1920)), 
				"CONGRATULATIONS", 
				1.5*(c.width/1920),
			);
			
			drawText(
				c.width/2 - ((12*(22*1.0*(c.width/1920))/2)), 
				c.height - (3*12*1.0*(c.width/1920)), 
				"CLICK FOR LEVEL SELECT", 
				1.0*(c.width/1920),
				false,
				"#888"
			);
		} else if (me.isDied) {
			drawText(
				c.width/2 - ((12*(18*1.5*(c.width/1920))/2)), 
				c.height - (6*12*1.5*(c.width/1920)), 
				"OH... LIFE HAS WIN :(", 
				1.5*(c.width/1920),
			);
			
			drawText(
				c.width/2 - ((12*(15*1.0*(c.width/1920))/2)), 
				c.height - (3*12*1.0*(c.width/1920)), 
				"CLICK FOR RETRY", 
				1.0*(c.width/1920),
				false,
				"#888"
			);
		}
	}
	
	if (SHOW_TARGET && mouse.pressed) {
		if (me.isDied) {
			fadeToLevel(level);
			mouse.pressed = false;
			oldMeRadius = me.radius;
		} else if (stage.ended) {
			fadeToLevel(0);
		} else {
			//if (Math.floor(mouse.pressedFrame)%60==0) {
				me.impulse(Math.cos(angle), Math.sin(angle));
			//}
			mouse.pressed = false;
			//mouse.pressedFrame+=(speed/(16.66/nbMs));
			if (!levelStart && mouse.pressed) {
				mouse.pressed = false;
			}
		}
	}

	//Maintenant grossi ou réduit les différentes cellules en fonction des collisions entre elle
	for (i=1; i<stage.elements.length; i++) {
		for (j=i+1; j<stage.elements.length; j++) {
			var a = stage.elements[i];
			var b = stage.elements[j];

			var distX = Math.abs(b.x - a.x);
			if (distX > a.radius+b.radius) { //Si rien que le x est plus grand que les radius, elles ne peuvent pas se toucher
				continue;
			}

			var distY = Math.abs(b.y - a.y);
			if (distY > a.radius+b.radius) { //Si rien que le y est plus grand que les radius, elles ne peuvent pas se toucher
				continue;
			}

			var distance = Math.hypot(distX, distY);
			if (distance<a.radius+b.radius) {
				a.collid = true;
				b.collid = true;
				a.done = false;
				b.done = false;

				//a est plus rapide, donc il doit impulser un peu de cette vitesse à b
				var inversed = false;
				if (a.velocity.speed < b.velocity.speed) {
					[a, b] = [b, a];
					inversed = true;
				}

				// Est ce que c'est le premier contact avec b ?
				if (a.contacts.indexOf(b)==-1) { //Si oui je met un coup d'impulse au plus lent
					a.contacts.push(b);
					b.contacts.push(a);
					var restitution = 0.1;

					var ratio = a.radius / b.radius; //En fonction du ratio entre les deux
					ratio = Math.min(0.5, ratio);
					restitution *= ratio*2.0;

					//Impulse dans la direction en fonction de l'angle d'impact
					var angle = Math.atan2(a.x-b.x, a.y - b.y);
					b.setVelocity(
						b.velocity.x + (-Math.sin(angle) * a.velocity.speed * restitution), 
						b.velocity.y + (-Math.cos(angle) * a.velocity.speed * restitution)
					);

					//b.setVelocity(b.velocity.x + (a.velocity.x * restitution), b.velocity.y + (a.velocity.y * restitution));
					a.setVelocity(a.velocity.x * (1-restitution), a.velocity.y * (1-restitution));
				}

				//Inverse pour avoir en permanence a qui est le plus gros
				if (a.radius<b.radius) {
					inversed=!inversed;
					[a, b] = [b, a];
				}

				//penetration est le nb de penetration (en négatif)
				var penetration = ((a.radius + b.radius) - distance) * 2;
				var S = Math.PI * (a.radius*a.radius);
				var newRadiusA = Math.sqrt((S + penetration) / Math.PI);

				//De combien dois-je augmenter mon radius pour gagner X en aire
				a.radius=newRadiusA;

				var S = Math.PI * (b.radius*b.radius);
				if (penetration<S) {
					b.radius = Math.sqrt((S - penetration) / Math.PI);
				} else {
					b.radius = 0;
					stage.elements.splice(inversed ? i : j,1);
					if (b==me) {
						me.isDied = true;
						gameOver();
					}
				}
			} else {
				//On n'est plus en contact
				var index = a.contacts.indexOf(b);
				if (index!=-1) {
					a.contacts.splice(index, 1);
					var index = b.contacts.indexOf(a);
					b.contacts.splice(index, 1);
				} 
			}
		}
	}

	if (stage.checkGoal()) {
		stage.ended = true;
		mouse.pressed = false;
	}
	
	var diff = me.radius/oldMeRadius;
	if (me.isDied) {
		diff = 1;
	}
	if (diff!=1) {
		targetZoom = targetZoom*diff; 
		targetZoom = Math.min(-50, targetZoom);
	}
	targetZoom = Math.max(maxZoom, targetZoom);
	if (zoom!=targetZoom) { //smooth zoom
		zoom += (targetZoom-zoom)*0.1/(16.66/nbMs);;
	}
};
window.requestAnimationFrame(gameLoop);	


//
// Font 5x7
//
var font = [];
font[0] = "01110100011001110101110011000101110";
font[1] = "00100011000010000100001000010001110";
font[2] = "01110100010000100110010001000011111";
font[3] = "01110100010000100110000011000101110";
font[4] = "00010001100101010010111110001000010";
font[5] = "11111100001111000001000011000101110";
font[6] = "00110010001000011110100011000101110";
font[7] = "11111000010001000100010000100001000";
font[8] = "01110100011000101110100011000101110";
font[9] = "01110100011000101111000010001001100";
font["A"] = "00100010101000110001111111000110001";
font["B"] = "11110010010100101110010010100111110";
font["C"] = "01110100011000010000100001000101110";
font["D"] = "11110010010100101001010010100111110";
font["E"] = "11111100001000011110100001000011111";
font["F"] = "11111100001000011110100001000010000";
font["G"] = "01110100011000010011100011000101111";
font["H"] = "10001100011000111111100011000110001";
font["I"] = "01110001000010000100001000010001110";
font["J"] = "01111000100001000010000101001001100";
font["K"] = "10001100101010011000101001001010001";
font["L"] = "10000100001000010000100001000011111";
font["M"] = "10001110111010110101100011000110001";
font["N"] = "10001100011100110101100111000110001";
font["O"] = "01110100011000110001100011000101110";
font["P"] = "11110100011000111110100001000010000";
font["Q"] = "01110100011000110001101011001001101";
font["R"] = "11110100011000111110101001001010001";
font["S"] = "01110100011000001110000011000101110";
font["T"] = "11111001000010000100001000010000100";
font["U"] = "10001100011000110001100011000101110";
font["V"] = "10001100011000110001100010101000100";
font["W"] = "10001100011000110101101011010101010";
font["X"] = "10001100010101000100010101000110001";
font["Y"] = "10001100011000101010001000010000100";
font["Z"] = "11111000010001000100010001000011111";
font["-"] = "00000000000000011111000000000000000";
font["."] = "00000000000000000000000000011000110";
font[","] = "00000000000000000000000110000100010";
font["!"] = "00100001000010000100001000000000100";
font["("] = "00010001000100001000010000010000010";
font[")"] = "00100000100000100001000010001000100";
font["v"] = "00001000010001000010101000110000100";
font["?"] = "01110100010000100010001000000000100";
font[":"] = "00000000000010000000001000000000000";





function drawText(posX, posY, text, scale, circle, color, color2) {
	var col = [color2 ? color2 : '#000', color ? color : '#FFF'];
	for (var j=0; j<col.length; j++) {
		ctx2D.fillStyle = col[j];
		j!=0 ? (posX-=2,posY-=2) : 0;
		var pX = posX;
		var pY = posY;
		for (var i=0; i<text.length; i++) {
			var index = 0;
			if (text[i]=="&") { 
				pX = posX;
				pY+=2*scale*12;
				continue
			}
			for (y=0; y<7; y++) {
				for (x=0; x<5; x++) {
					if (text[i]==" ") { continue; }
					if (font[text[i]][index]!="0") {
						if (circle) {
							ctx2D.beginPath();	
							ctx2D.arc(
								pX+x*2*scale + ((Math.sin((frame+pX+x*20.0+y*15)/20.0)*(ratioText*2.0*scale/5))), 
								pY+y*2*scale + ((Math.sin((frame+pX+x*20.0+y*17.0)/20.0)*(ratioText*2.0*scale/5))), 
								2.5*scale*0.5,
								0, 
								2*Math.PI);
							ctx2D.fill();
							
						} else {
							ctx2D.fillRect(
								pX+x*2*scale, 
								pY+y*2*scale, 
								1.8*scale, 
								1.8*scale); //1.8 à la place de 3 pour des carrés*/
						}
						
					}
					index++;
				}
			}
			pX += 12*scale;
		}
	}
};

gameOver = function() {
	mouse.pressed = false;
};

var zoom = -100;
var targetZoom = zoom;
var frame = 0;

//
// Draw the scene.
//
function drawScene(gl, programInfo, buffers) {
	gl.clear(gl.COLOR_BUFFER_BIT);
	
	for (i=0; i<stage.elements.length; i++) {
		if (i>0 && level<1) {
			return;
		}
		var elm = stage.elements[i];
		
		// Set the drawing position to the "identity" point, which is
		// the center of the scene.
		elm.modelViewMatrix = mat44.create();
	
		mat44.translate(
			elm.modelViewMatrix,     // destination matrix
			elm.modelViewMatrix,     // matrix to translate
			[elm.x - me.x + extraDecal.x, -elm.y + me.y - extraDecal.y, zoom]
		);

		if (!elm.done) {
			elm.done = true;
			elm.bufferPosition = gl.createBuffer();
			
			elm.positions = [
				elm.radius,  elm.radius,
			       -elm.radius,  elm.radius,
				elm.radius, -elm.radius,
			       -elm.radius, -elm.radius
			];
			elm.float32Positions = new Float32Array(elm.positions);
			gl.bindBuffer(gl.ARRAY_BUFFER, elm.bufferPosition);
			gl.bufferData(
				gl.ARRAY_BUFFER,
				elm.float32Positions,
				gl.STATIC_DRAW
			);
		} else {
			gl.bindBuffer(gl.ARRAY_BUFFER, elm.bufferPosition);
		}
		
		gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
		gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
		gl.useProgram(programInfo.program);

		if (elm.collid) {
			if (elm==me && elm.collidPercent<0.05) {
				playNote(-12,song.tracks[5].instrument);
			}
			elm.collidPercent = (elm.collidPercent*0.95) + 0.05;
		} else {
			elm.collidPercent*=0.95;
		}
		elm.collidPercent = Math.min(0.98, elm.collidPercent);
		elm.collidPercent = Math.max(0.0, elm.collidPercent);
		
		// Set the shader uniforms
		gl.uniform1f(programInfo.uniformLocations.radius, elm.radius);
		gl.uniform1f(programInfo.uniformLocations.iTime, (frame/60));
		gl.uniform1f(programInfo.uniformLocations.meRadius, me.radius);
		gl.uniform1f(programInfo.uniformLocations.uvBack, uvBack);
		gl.uniform1i(programInfo.uniformLocations.type, elm.type);
		gl.uniform1f(programInfo.uniformLocations.collid, elm.collidPercent);
		gl.uniform1f(programInfo.uniformLocations.fade, ctx2D.globalAlpha);
		gl.uniformMatrix4fv(programInfo.uniformLocations.projectionMatrix, false, projectionMatrix);
		gl.uniformMatrix4fv(programInfo.uniformLocations.modelViewMatrix, false, elm.modelViewMatrix);
		gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
	}
};

//
// Initialize a shader program, so WebGL knows how to draw our data
//
function initShaderProgram(gl, vsSource, fsSource) {
	const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
	const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

	// Create the shader program
	const shaderProgram = gl.createProgram();
	gl.attachShader(shaderProgram, vertexShader);
	gl.attachShader(shaderProgram, fragmentShader);
	gl.linkProgram(shaderProgram);

	if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
		alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
		return null;
	}
	return shaderProgram;
};

//
// creates a shader of the given type, uploads the source and
// compiles it.
//
function loadShader(gl, type, source) {
	const shader = gl.createShader(type);

	gl.shaderSource(shader, source);
	gl.compileShader(shader);
	if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
		alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
		gl.deleteShader(shader);
		return null;
	}
	return shader;
};


//
// MUSIC
// 
var song = {
	tempo:100,
	nbBars:8,
	tracks:[
		{
			instrument:{ //pad
				nbHarmoniques:1,
				attack:22050,
				sustain:1.6
			},
			detune:-12,
			bars:[
				[[8,0,3,12]], //C
				[[8,0,3,12]], //C
				[[1,5,8,13]], //F
				[[1,5,8,13]], //F
				[[5,8,0,12]], //Am
				[[3,7,10]],   //G
				[[1,5,8]],    //F
				[[1,5,8]]     //F
			]
		},{
			instrument:{  //bass
				nbHarmoniques:16,
				attack:1000,
				sustain:0.5
			},
			detune:-36-12,
			bars:[
				[8],
				[8],
				[13],
				[13],
				[5],
				[3],
				[13],
				[13]
			]
		},{
			instrument:{
				nbHarmoniques:16,
				attack:22050,
				sustain:2.0
			},
			detune:-12,
			bars:[
				[[[0,3,8,12,15,20]]],
				[[[0,3,8,12,15]]],
				[[[1,5,8,13,17,20]]],
				[[[1,5,8,13,17,20]]],
				[[[0,5,8,12,17]]],
				[[[3,7,10,15,19]]],
				[[[1,5,8,13,17]]],
				[[[1,5,8,13,17]]],
			]
		},{
			instrument:{  //cymbal
				nbHarmoniques:1,
				attack:22050,
				sustain:0.5,
				osc:Math.random
			},
			detune:0,
			bars:[
				[],
				[],
				[],
				[],
				[],
				[],
				[],
				[,,,,,,,,,,,,,,,-24]
			]
		},{
			instrument:{ //bell
				nbHarmoniques:1,
				attack:44100*0.05,
				sustain:1.0
			},
			detune:0,
			bars:[
				[[[0,3,8,12,15,20]],[[0,3,8,12,15,20]],[[0,3,8,12,15,20]],[[0,3,8,12,15,20]],[[0,3,8,12,15,20]],[[0,3,8,12,15,20]],[[0,3,8,12,15,20]],[[0,3,8,12,15,20]],[[0,3,8,12,15,20]],[[0,3,8,12,15,20]],[[0,3,8,12,15,20]],[[0,3,8,12,15,20]]], //C
				[], //C
				[], // F
				
				[], //F
				[], //Am
				[], //G
				[], //F				
				[[[1,5,8,13,17]],[[1,5,8,13,17]],[[1,5,8,13,17]],[[1,5,8,13,17]],[[1,5,8,13,17]],[[1,5,8,13,17]],[[1,5,8,13,17]],[[1,5,8,13,17]],[[1,5,8,13,17]],[[1,5,8,13,17]],[[1,5,8,13,17]],[[1,5,8,13,17]],[[1,5,8,13,17]],[[1,5,8,13,17]],[[1,5,8,13,17]],[[1,5,8,13,17]]]
			]
		},{
			instrument:{  //cymbal
				nbHarmoniques:1,
				attack:2000,
				sustain:0.5,
				osc:Math.random //Math.random
			},
			detune:0,
			bars:[
				[],
				[],
				[],
				[],
				[],
				[],
				[],
				[]
			]
		},{
			instrument:{  //cymbal
				nbHarmoniques:16,
				attack:2000,
				sustain:0.5,
				osc:Math.random
			},
			detune:-48,
			bars:[
				[],
				[],
				[],
				[],
				[],
				[],
				[],
				[]
			]
		}
	]
};


var context = new AudioContext();
context.suspend();

var timeStart = -1;
var oldBeatNumber = -1;
var sampleRate = 44100;
var notes = [];

generateWave = function() {
	song.tracks.forEach(function(track) {
		var inst = track.instrument;
		inst.osc = inst.osc || Math.sin;
		inst.effect = inst.effect || {
			detune:1.005,
			delay:40,
			volume:1.0
		};
		var n = {
			harmoniquesEnd:[],
			inst:inst
		};

		inst.buffer = new Float32Array(44100*30);
		for (var h=1; h<=inst.nbHarmoniques; h++) {
			n.harmoniquesEnd[h] = (sampleRate * [,9.5, 7.2, 4.1, 4.8, 3.75, 4.35, 3.35, 2.4, 2.8, 2.1, 1.9, 1.7, 1.6, 1.5, 1.5, 1.5][h] * 1.0) * inst.sustain;
		}
		notes.push(n);
	});
	
	
	var nbSamples = sampleRate * 30;
	for (var sampleNumber = 0; sampleNumber < nbSamples; sampleNumber++) {
		for (var nn=0; nn<notes.length; nn++) {
			var n = notes[nn];
			var offsetValue = 0;
			for (var h=1; h<=n.inst.nbHarmoniques; h++) {
				if (sampleNumber>n.harmoniquesEnd[h]) { 
					// Si on considère que si une harmonique est terminée, celles d'après aussi
					break;
				} else {
					var C = 1 -(sampleNumber / n.harmoniquesEnd[h]); //Renvoi un nb entre 0.0 et 1.0 qui indique où on est est dans le fade
					var volume = [,0.75,0.75,0.72,0.75,0.66,0.645,0.6,0.585,0.54,0.51,0.5175,0.48,0.48,0.45,0.48,0.405][h] * C;  //Donne un nombre entre 0 et le volume nomimal. 0 si est à la fin. volumeNomimal si on est au début. Descente linéaire entre les deux
					if (sampleNumber-0 < n.inst.attack) {
						volume = (sampleNumber/n.inst.attack) * volume;
					}

					//Créer une pente très forte au début
					volume = Math.pow(volume, 8);
					volume*=0.38;
					if (nn==2) {
						volume*=0.5;	
					}

					var a = sampleNumber / (sampleRate / (440*h) / (Math.PI * 2));
					offsetValue += volume * n.inst.osc(a); 

					//Chorus
					if (n.inst.effect) {
						var effectDelay = n.inst.effect.delay;
						var effectVolume = n.inst.effect.volume;
						var effectDetune = n.inst.effect.detune;
						//Je créé plusieurs effect sur lequel je boucle
						while (effectVolume>0.01) {
							var effectDelayenSamples = sampleRate / 1000 * effectDelay;
							if (sampleNumber < nbSamples - effectDelayenSamples) {
								var v = n.inst.osc(sampleNumber / (sampleRate / (440*h * effectDetune) / (Math.PI * 2)));
								n.inst.buffer[sampleNumber+effectDelayenSamples] += (volume * v * effectVolume) / 2.0;
							}
							effectDelay+=n.inst.effect.delay;
							effectVolume*=n.inst.effect.volume;
							effectDetune*=n.inst.effect.detune;
							if (!n.inst.effect.repeat) {
								break;
							}
						}
					}
					
				}
			}
			
			n.inst.buffer[sampleNumber] += offsetValue;
		}
	}
	oldDT = performance.now();
};


//requestAnimationFrame(playSong); 
var globalDetune = 0;
var targetGlobalDetune = 0;
var allNodes = [];
var soundStarted = false;
var sick = false;

playNote = function(pitch, inst, start) {
	if (muted) { return; }
	//pitch+=Math.floor(Math.random()*2);
	//pitch+=(Math.random()*12)-6;
	var buffer = inst.buffer;
	var audioBuffer = context.createBuffer(2, context.sampleRate*4, context.sampleRate);
	audioBuffer.copyToChannel(buffer, 0);
	audioBuffer.copyToChannel(buffer, 1, 882);
	
	var source = context.createBufferSource();
	source.playbackRate.value = Math.pow(2.0, pitch / 12.0);
	source.detune.value = globalDetune;
	source.buffer = audioBuffer;
	source.connect(context.destination);
	source.start(0, start ? start : 0);
	source.onended = function() {
		for (var i=0; i<allNodes.length; i++) {
			if (allNodes[i]==this) {
				allNodes.splice(i,1);
				break;
			}
		}
	};
	allNodes.push(source);
	return source;
};

playSong = function(dt){
	requestAnimationFrame(playSong);
	
	if (speed==2) { 
		targetGlobalDetune = 200;
	} else if (speed==1) {
		targetGlobalDetune = 0;
	} else if (speed==0.5) {
		targetGlobalDetune = -200;
	}
	if (muted) { return ; }
	if (globalDetune!=targetGlobalDetune) { 
		globalDetune += (targetGlobalDetune-globalDetune)*0.1;
		allNodes.forEach(function(elm) {
			elm.detune.value=globalDetune;
		})
	}
	
	if (timeStart==-1) {
		timeStart = dt;
	}

	var beatNumber = Math.floor((dt-timeStart) / (60 / song.tempo / 4 * 1000));
	beatNumber%=song.nbBars*16;
	
	if (beatNumber!=oldBeatNumber) {
		if (beatNumber==0) {
			var A = [[  ,  ,  ,  ,8 ,  ,  ,  ,15,  ,  ,  , 5],[12,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ],
			[  ,  ,  ,  ,3 ,  ,  ,  ,8 ,  ,  ,  ,7 ],[5 ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ],
			[  ,  ,  ,  ,13,  ,  ,  ,15,  ,  ,  ,7 ],[8 ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ],
			[1 ,  ,5 ,  ,8 ,  ,13,  ,15,  ,17,  ,19],[20,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ],
			[  ,  ,  ,  ,  ,  ,  ,12,  ,  ,  ,10,  ,  ,  ,  ],[8 ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ]
			];
			var AA = Math.floor(Math.random() * A.length/2);
			song.tracks[4].bars[3] = A[AA*2];
			song.tracks[4].bars[4] = A[AA*2+1];


			var B = [[  ,  ,13,  ,  ,  ,  ,  ,  ,  ,  ,  ,12],[8 ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ],
			[  ,  ,7 ,  ,  ,  ,  ,  ,  ,  ,  ,10,  ],[8 ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ],
			[  ,  ,10,  ,  ,  ,  ,  ,  ,  ,  ,  ,15],[  ,13,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ],
			[  ,  ,15,  ,  ,13,  ,8 ,  ,7 ,  ,  ,5 ],[  ,8,  ,7,  ,5,  ,  ,  ,  ,  ,  ,  ,  ],
			[  ,  ,7 ,  ,  ,  ,  ,  ,  ,  ,5 ,  ,  ],[  ,  ,8 ,  ,  ,  ,7 ,  ,  ,5 ]];

			var BB = Math.floor(Math.random() * B.length/2);
			song.tracks[4].bars[5] = B[BB*2];
			song.tracks[4].bars[6] = B[BB*2+1];
		}

		song.tracks.forEach(function(track) {
			var notes = track.bars[Math.floor(beatNumber/16)][beatNumber%16];
			if (typeof(notes)=="number") {
				playNote(notes + track.detune, track.instrument);
			} else if (typeof(notes)=="object") {
				notes.forEach(function(note) {
					if (typeof(note)=="number") {
						playNote(note + track.detune, track.instrument);
					} else {
						playNote(note[Math.floor(Math.random() * note.length)]-12 + track.detune, track.instrument);
					}
				});
			}
		});
	}
	oldBeatNumber = beatNumber;
	boula = 1;
};

generateWave();
</script>
</body>
</html>
