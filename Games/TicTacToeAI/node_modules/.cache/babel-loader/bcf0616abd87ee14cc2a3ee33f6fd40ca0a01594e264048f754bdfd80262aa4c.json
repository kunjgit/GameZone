{"ast":null,"code":"import _toConsumableArray from \"C:/Users/USER/Desktop/TicTacToeAI/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"C:/Users/USER/Desktop/TicTacToeAI/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"C:/Users/USER/Desktop/TicTacToeAI/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"transitionEnd\", \"transition\"];\nimport { isNumericalString } from '../../utils/is-numerical-string.mjs';\nimport { isZeroValueString } from '../../utils/is-zero-value-string.mjs';\nimport { resolveFinalValueInKeyframes } from '../../utils/resolve-value.mjs';\nimport { motionValue } from '../../value/index.mjs';\nimport { complex } from '../../value/types/complex/index.mjs';\nimport { getAnimatableNone } from '../dom/value-types/animatable-none.mjs';\nimport { findValueType } from '../dom/value-types/find.mjs';\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\n\n/**\n * Set VisualElement's MotionValue, creating a new MotionValue for it if\n * it doesn't exist.\n */\nfunction setMotionValue(visualElement, key, value) {\n  if (visualElement.hasValue(key)) {\n    visualElement.getValue(key).set(value);\n  } else {\n    visualElement.addValue(key, motionValue(value));\n  }\n}\nfunction setTarget(visualElement, definition) {\n  var resolved = resolveVariant(visualElement, definition);\n  var _ref = resolved ? visualElement.makeTargetAnimatable(resolved, false) : {},\n    _ref$transitionEnd = _ref.transitionEnd,\n    transitionEnd = _ref$transitionEnd === void 0 ? {} : _ref$transitionEnd,\n    _ref$transition = _ref.transition,\n    transition = _ref$transition === void 0 ? {} : _ref$transition,\n    target = _objectWithoutProperties(_ref, _excluded);\n  target = _objectSpread(_objectSpread({}, target), transitionEnd);\n  for (var key in target) {\n    var value = resolveFinalValueInKeyframes(target[key]);\n    setMotionValue(visualElement, key, value);\n  }\n}\nfunction setVariants(visualElement, variantLabels) {\n  var reversedLabels = _toConsumableArray(variantLabels).reverse();\n  reversedLabels.forEach(function (key) {\n    var variant = visualElement.getVariant(key);\n    variant && setTarget(visualElement, variant);\n    if (visualElement.variantChildren) {\n      visualElement.variantChildren.forEach(function (child) {\n        setVariants(child, variantLabels);\n      });\n    }\n  });\n}\nfunction setValues(visualElement, definition) {\n  if (Array.isArray(definition)) {\n    return setVariants(visualElement, definition);\n  } else if (typeof definition === \"string\") {\n    return setVariants(visualElement, [definition]);\n  } else {\n    setTarget(visualElement, definition);\n  }\n}\nfunction checkTargetForNewValues(visualElement, target, origin) {\n  var _a, _b;\n  var newValueKeys = Object.keys(target).filter(function (key) {\n    return !visualElement.hasValue(key);\n  });\n  var numNewValues = newValueKeys.length;\n  if (!numNewValues) return;\n  for (var i = 0; i < numNewValues; i++) {\n    var key = newValueKeys[i];\n    var targetValue = target[key];\n    var value = null;\n    /**\n     * If the target is a series of keyframes, we can use the first value\n     * in the array. If this first value is null, we'll still need to read from the DOM.\n     */\n    if (Array.isArray(targetValue)) {\n      value = targetValue[0];\n    }\n    /**\n     * If the target isn't keyframes, or the first keyframe was null, we need to\n     * first check if an origin value was explicitly defined in the transition as \"from\",\n     * if not read the value from the DOM. As an absolute fallback, take the defined target value.\n     */\n    if (value === null) {\n      value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];\n    }\n    /**\n     * If value is still undefined or null, ignore it. Preferably this would throw,\n     * but this was causing issues in Framer.\n     */\n    if (value === undefined || value === null) continue;\n    if (typeof value === \"string\" && (isNumericalString(value) || isZeroValueString(value))) {\n      // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n      value = parseFloat(value);\n    } else if (!findValueType(value) && complex.test(targetValue)) {\n      value = getAnimatableNone(key, targetValue);\n    }\n    visualElement.addValue(key, motionValue(value, {\n      owner: visualElement\n    }));\n    if (origin[key] === undefined) {\n      origin[key] = value;\n    }\n    if (value !== null) visualElement.setBaseTarget(key, value);\n  }\n}\nfunction getOriginFromTransition(key, transition) {\n  if (!transition) return;\n  var valueTransition = transition[key] || transition[\"default\"] || transition;\n  return valueTransition.from;\n}\nfunction getOrigin(target, transition, visualElement) {\n  var origin = {};\n  for (var key in target) {\n    var transitionOrigin = getOriginFromTransition(key, transition);\n    if (transitionOrigin !== undefined) {\n      origin[key] = transitionOrigin;\n    } else {\n      var value = visualElement.getValue(key);\n      if (value) {\n        origin[key] = value.get();\n      }\n    }\n  }\n  return origin;\n}\nexport { checkTargetForNewValues, getOrigin, getOriginFromTransition, setTarget, setValues };","map":{"version":3,"names":["isNumericalString","isZeroValueString","resolveFinalValueInKeyframes","motionValue","complex","getAnimatableNone","findValueType","resolveVariant","setMotionValue","visualElement","key","value","hasValue","getValue","set","addValue","setTarget","definition","resolved","_ref","makeTargetAnimatable","_ref$transitionEnd","transitionEnd","_ref$transition","transition","target","_objectWithoutProperties","_excluded","_objectSpread","setVariants","variantLabels","reversedLabels","_toConsumableArray","reverse","forEach","variant","getVariant","variantChildren","child","setValues","Array","isArray","checkTargetForNewValues","origin","_a","_b","newValueKeys","Object","keys","filter","numNewValues","length","i","targetValue","readValue","undefined","parseFloat","test","owner","setBaseTarget","getOriginFromTransition","valueTransition","from","getOrigin","transitionOrigin","get"],"sources":["C:/Users/USER/Desktop/TicTacToeAI/node_modules/framer-motion/dist/es/render/utils/setters.mjs"],"sourcesContent":["import { isNumericalString } from '../../utils/is-numerical-string.mjs';\nimport { isZeroValueString } from '../../utils/is-zero-value-string.mjs';\nimport { resolveFinalValueInKeyframes } from '../../utils/resolve-value.mjs';\nimport { motionValue } from '../../value/index.mjs';\nimport { complex } from '../../value/types/complex/index.mjs';\nimport { getAnimatableNone } from '../dom/value-types/animatable-none.mjs';\nimport { findValueType } from '../dom/value-types/find.mjs';\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\n\n/**\n * Set VisualElement's MotionValue, creating a new MotionValue for it if\n * it doesn't exist.\n */\nfunction setMotionValue(visualElement, key, value) {\n    if (visualElement.hasValue(key)) {\n        visualElement.getValue(key).set(value);\n    }\n    else {\n        visualElement.addValue(key, motionValue(value));\n    }\n}\nfunction setTarget(visualElement, definition) {\n    const resolved = resolveVariant(visualElement, definition);\n    let { transitionEnd = {}, transition = {}, ...target } = resolved ? visualElement.makeTargetAnimatable(resolved, false) : {};\n    target = { ...target, ...transitionEnd };\n    for (const key in target) {\n        const value = resolveFinalValueInKeyframes(target[key]);\n        setMotionValue(visualElement, key, value);\n    }\n}\nfunction setVariants(visualElement, variantLabels) {\n    const reversedLabels = [...variantLabels].reverse();\n    reversedLabels.forEach((key) => {\n        const variant = visualElement.getVariant(key);\n        variant && setTarget(visualElement, variant);\n        if (visualElement.variantChildren) {\n            visualElement.variantChildren.forEach((child) => {\n                setVariants(child, variantLabels);\n            });\n        }\n    });\n}\nfunction setValues(visualElement, definition) {\n    if (Array.isArray(definition)) {\n        return setVariants(visualElement, definition);\n    }\n    else if (typeof definition === \"string\") {\n        return setVariants(visualElement, [definition]);\n    }\n    else {\n        setTarget(visualElement, definition);\n    }\n}\nfunction checkTargetForNewValues(visualElement, target, origin) {\n    var _a, _b;\n    const newValueKeys = Object.keys(target).filter((key) => !visualElement.hasValue(key));\n    const numNewValues = newValueKeys.length;\n    if (!numNewValues)\n        return;\n    for (let i = 0; i < numNewValues; i++) {\n        const key = newValueKeys[i];\n        const targetValue = target[key];\n        let value = null;\n        /**\n         * If the target is a series of keyframes, we can use the first value\n         * in the array. If this first value is null, we'll still need to read from the DOM.\n         */\n        if (Array.isArray(targetValue)) {\n            value = targetValue[0];\n        }\n        /**\n         * If the target isn't keyframes, or the first keyframe was null, we need to\n         * first check if an origin value was explicitly defined in the transition as \"from\",\n         * if not read the value from the DOM. As an absolute fallback, take the defined target value.\n         */\n        if (value === null) {\n            value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];\n        }\n        /**\n         * If value is still undefined or null, ignore it. Preferably this would throw,\n         * but this was causing issues in Framer.\n         */\n        if (value === undefined || value === null)\n            continue;\n        if (typeof value === \"string\" &&\n            (isNumericalString(value) || isZeroValueString(value))) {\n            // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n            value = parseFloat(value);\n        }\n        else if (!findValueType(value) && complex.test(targetValue)) {\n            value = getAnimatableNone(key, targetValue);\n        }\n        visualElement.addValue(key, motionValue(value, { owner: visualElement }));\n        if (origin[key] === undefined) {\n            origin[key] = value;\n        }\n        if (value !== null)\n            visualElement.setBaseTarget(key, value);\n    }\n}\nfunction getOriginFromTransition(key, transition) {\n    if (!transition)\n        return;\n    const valueTransition = transition[key] || transition[\"default\"] || transition;\n    return valueTransition.from;\n}\nfunction getOrigin(target, transition, visualElement) {\n    const origin = {};\n    for (const key in target) {\n        const transitionOrigin = getOriginFromTransition(key, transition);\n        if (transitionOrigin !== undefined) {\n            origin[key] = transitionOrigin;\n        }\n        else {\n            const value = visualElement.getValue(key);\n            if (value) {\n                origin[key] = value.get();\n            }\n        }\n    }\n    return origin;\n}\n\nexport { checkTargetForNewValues, getOrigin, getOriginFromTransition, setTarget, setValues };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}