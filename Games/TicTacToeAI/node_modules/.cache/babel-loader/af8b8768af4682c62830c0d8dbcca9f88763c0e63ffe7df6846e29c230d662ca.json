{"ast":null,"code":"import { progress } from '../../../utils/progress.mjs';\nimport { calcLength } from '../../../projection/geometry/delta-calc.mjs';\nimport { clamp } from '../../../utils/clamp.mjs';\nimport { mix } from '../../../utils/mix.mjs';\n\n/**\n * Apply constraints to a point. These constraints are both physical along an\n * axis, and an elastic factor that determines how much to constrain the point\n * by if it does lie outside the defined parameters.\n */\nfunction applyConstraints(point, _ref, elastic) {\n  var min = _ref.min,\n    max = _ref.max;\n  if (min !== undefined && point < min) {\n    // If we have a min point defined, and this is outside of that, constrain\n    point = elastic ? mix(min, point, elastic.min) : Math.max(point, min);\n  } else if (max !== undefined && point > max) {\n    // If we have a max point defined, and this is outside of that, constrain\n    point = elastic ? mix(max, point, elastic.max) : Math.min(point, max);\n  }\n  return point;\n}\n/**\n * Calculate constraints in terms of the viewport when defined relatively to the\n * measured axis. This is measured from the nearest edge, so a max constraint of 200\n * on an axis with a max value of 300 would return a constraint of 500 - axis length\n */\nfunction calcRelativeAxisConstraints(axis, min, max) {\n  return {\n    min: min !== undefined ? axis.min + min : undefined,\n    max: max !== undefined ? axis.max + max - (axis.max - axis.min) : undefined\n  };\n}\n/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured bounding box.\n */\nfunction calcRelativeConstraints(layoutBox, _ref2) {\n  var top = _ref2.top,\n    left = _ref2.left,\n    bottom = _ref2.bottom,\n    right = _ref2.right;\n  return {\n    x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)\n  };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative axis\n */\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n  var min = constraintsAxis.min - layoutAxis.min;\n  var max = constraintsAxis.max - layoutAxis.max;\n  // If the constraints axis is actually smaller than the layout axis then we can\n  // flip the constraints\n  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {\n    var _ref3 = [max, min];\n    min = _ref3[0];\n    max = _ref3[1];\n  }\n  return {\n    min: min,\n    max: max\n  };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative box\n */\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\n  return {\n    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)\n  };\n}\n/**\n * Calculate a transform origin relative to the source axis, between 0-1, that results\n * in an asthetically pleasing scale/transform needed to project from source to target.\n */\nfunction calcOrigin(source, target) {\n  var origin = 0.5;\n  var sourceLength = calcLength(source);\n  var targetLength = calcLength(target);\n  if (targetLength > sourceLength) {\n    origin = progress(target.min, target.max - sourceLength, source.min);\n  } else if (sourceLength > targetLength) {\n    origin = progress(source.min, source.max - targetLength, target.min);\n  }\n  return clamp(0, 1, origin);\n}\n/**\n * Rebase the calculated viewport constraints relative to the layout.min point.\n */\nfunction rebaseAxisConstraints(layout, constraints) {\n  var relativeConstraints = {};\n  if (constraints.min !== undefined) {\n    relativeConstraints.min = constraints.min - layout.min;\n  }\n  if (constraints.max !== undefined) {\n    relativeConstraints.max = constraints.max - layout.min;\n  }\n  return relativeConstraints;\n}\nvar defaultElastic = 0.35;\n/**\n * Accepts a dragElastic prop and returns resolved elastic values for each axis.\n */\nfunction resolveDragElastic() {\n  var dragElastic = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultElastic;\n  if (dragElastic === false) {\n    dragElastic = 0;\n  } else if (dragElastic === true) {\n    dragElastic = defaultElastic;\n  }\n  return {\n    x: resolveAxisElastic(dragElastic, \"left\", \"right\"),\n    y: resolveAxisElastic(dragElastic, \"top\", \"bottom\")\n  };\n}\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\n  return {\n    min: resolvePointElastic(dragElastic, minLabel),\n    max: resolvePointElastic(dragElastic, maxLabel)\n  };\n}\nfunction resolvePointElastic(dragElastic, label) {\n  return typeof dragElastic === \"number\" ? dragElastic : dragElastic[label] || 0;\n}\nexport { applyConstraints, calcOrigin, calcRelativeAxisConstraints, calcRelativeConstraints, calcViewportAxisConstraints, calcViewportConstraints, defaultElastic, rebaseAxisConstraints, resolveAxisElastic, resolveDragElastic, resolvePointElastic };","map":{"version":3,"names":["progress","calcLength","clamp","mix","applyConstraints","point","_ref","elastic","min","max","undefined","Math","calcRelativeAxisConstraints","axis","calcRelativeConstraints","layoutBox","_ref2","top","left","bottom","right","x","y","calcViewportAxisConstraints","layoutAxis","constraintsAxis","_ref3","calcViewportConstraints","constraintsBox","calcOrigin","source","target","origin","sourceLength","targetLength","rebaseAxisConstraints","layout","constraints","relativeConstraints","defaultElastic","resolveDragElastic","dragElastic","arguments","length","resolveAxisElastic","minLabel","maxLabel","resolvePointElastic","label"],"sources":["C:/Users/USER/Desktop/TicTacToeAI/node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.mjs"],"sourcesContent":["import { progress } from '../../../utils/progress.mjs';\nimport { calcLength } from '../../../projection/geometry/delta-calc.mjs';\nimport { clamp } from '../../../utils/clamp.mjs';\nimport { mix } from '../../../utils/mix.mjs';\n\n/**\n * Apply constraints to a point. These constraints are both physical along an\n * axis, and an elastic factor that determines how much to constrain the point\n * by if it does lie outside the defined parameters.\n */\nfunction applyConstraints(point, { min, max }, elastic) {\n    if (min !== undefined && point < min) {\n        // If we have a min point defined, and this is outside of that, constrain\n        point = elastic ? mix(min, point, elastic.min) : Math.max(point, min);\n    }\n    else if (max !== undefined && point > max) {\n        // If we have a max point defined, and this is outside of that, constrain\n        point = elastic ? mix(max, point, elastic.max) : Math.min(point, max);\n    }\n    return point;\n}\n/**\n * Calculate constraints in terms of the viewport when defined relatively to the\n * measured axis. This is measured from the nearest edge, so a max constraint of 200\n * on an axis with a max value of 300 would return a constraint of 500 - axis length\n */\nfunction calcRelativeAxisConstraints(axis, min, max) {\n    return {\n        min: min !== undefined ? axis.min + min : undefined,\n        max: max !== undefined\n            ? axis.max + max - (axis.max - axis.min)\n            : undefined,\n    };\n}\n/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured bounding box.\n */\nfunction calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {\n    return {\n        x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n        y: calcRelativeAxisConstraints(layoutBox.y, top, bottom),\n    };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative axis\n */\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n    let min = constraintsAxis.min - layoutAxis.min;\n    let max = constraintsAxis.max - layoutAxis.max;\n    // If the constraints axis is actually smaller than the layout axis then we can\n    // flip the constraints\n    if (constraintsAxis.max - constraintsAxis.min <\n        layoutAxis.max - layoutAxis.min) {\n        [min, max] = [max, min];\n    }\n    return { min, max };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative box\n */\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\n    return {\n        x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n        y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y),\n    };\n}\n/**\n * Calculate a transform origin relative to the source axis, between 0-1, that results\n * in an asthetically pleasing scale/transform needed to project from source to target.\n */\nfunction calcOrigin(source, target) {\n    let origin = 0.5;\n    const sourceLength = calcLength(source);\n    const targetLength = calcLength(target);\n    if (targetLength > sourceLength) {\n        origin = progress(target.min, target.max - sourceLength, source.min);\n    }\n    else if (sourceLength > targetLength) {\n        origin = progress(source.min, source.max - targetLength, target.min);\n    }\n    return clamp(0, 1, origin);\n}\n/**\n * Rebase the calculated viewport constraints relative to the layout.min point.\n */\nfunction rebaseAxisConstraints(layout, constraints) {\n    const relativeConstraints = {};\n    if (constraints.min !== undefined) {\n        relativeConstraints.min = constraints.min - layout.min;\n    }\n    if (constraints.max !== undefined) {\n        relativeConstraints.max = constraints.max - layout.min;\n    }\n    return relativeConstraints;\n}\nconst defaultElastic = 0.35;\n/**\n * Accepts a dragElastic prop and returns resolved elastic values for each axis.\n */\nfunction resolveDragElastic(dragElastic = defaultElastic) {\n    if (dragElastic === false) {\n        dragElastic = 0;\n    }\n    else if (dragElastic === true) {\n        dragElastic = defaultElastic;\n    }\n    return {\n        x: resolveAxisElastic(dragElastic, \"left\", \"right\"),\n        y: resolveAxisElastic(dragElastic, \"top\", \"bottom\"),\n    };\n}\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\n    return {\n        min: resolvePointElastic(dragElastic, minLabel),\n        max: resolvePointElastic(dragElastic, maxLabel),\n    };\n}\nfunction resolvePointElastic(dragElastic, label) {\n    return typeof dragElastic === \"number\"\n        ? dragElastic\n        : dragElastic[label] || 0;\n}\n\nexport { applyConstraints, calcOrigin, calcRelativeAxisConstraints, calcRelativeConstraints, calcViewportAxisConstraints, calcViewportConstraints, defaultElastic, rebaseAxisConstraints, resolveAxisElastic, resolveDragElastic, resolvePointElastic };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}