{"ast":null,"code":"import _slicedToArray from \"C:/Users/USER/Desktop/TicTacToeAI/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"C:/Users/USER/Desktop/TicTacToeAI/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"C:/Users/USER/Desktop/TicTacToeAI/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/USER/Desktop/TicTacToeAI/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/USER/Desktop/TicTacToeAI/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/USER/Desktop/TicTacToeAI/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { frame } from '../../../frameloop/index.mjs';\nimport React__default, { useContext } from 'react';\nimport { usePresence } from '../../../components/AnimatePresence/use-presence.mjs';\nimport { LayoutGroupContext } from '../../../context/LayoutGroupContext.mjs';\nimport { SwitchLayoutGroupContext } from '../../../context/SwitchLayoutGroupContext.mjs';\nimport { globalProjectionState } from '../../../projection/node/state.mjs';\nimport { correctBorderRadius } from '../../../projection/styles/scale-border-radius.mjs';\nimport { correctBoxShadow } from '../../../projection/styles/scale-box-shadow.mjs';\nimport { addScaleCorrector } from '../../../projection/styles/scale-correction.mjs';\nvar MeasureLayoutWithContext = /*#__PURE__*/function (_React__default$Compo) {\n  _inherits(MeasureLayoutWithContext, _React__default$Compo);\n  var _super = _createSuper(MeasureLayoutWithContext);\n  function MeasureLayoutWithContext() {\n    _classCallCheck(this, MeasureLayoutWithContext);\n    return _super.apply(this, arguments);\n  }\n  _createClass(MeasureLayoutWithContext, [{\n    key: \"componentDidMount\",\n    value:\n    /**\n     * This only mounts projection nodes for components that\n     * need measuring, we might want to do it for all components\n     * in order to incorporate transforms\n     */\n    function componentDidMount() {\n      var _this = this;\n      var _this$props = this.props,\n        visualElement = _this$props.visualElement,\n        layoutGroup = _this$props.layoutGroup,\n        switchLayoutGroup = _this$props.switchLayoutGroup,\n        layoutId = _this$props.layoutId;\n      var projection = visualElement.projection;\n      addScaleCorrector(defaultScaleCorrectors);\n      if (projection) {\n        if (layoutGroup.group) layoutGroup.group.add(projection);\n        if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {\n          switchLayoutGroup.register(projection);\n        }\n        projection.root.didUpdate();\n        projection.addEventListener(\"animationComplete\", function () {\n          _this.safeToRemove();\n        });\n        projection.setOptions(_objectSpread(_objectSpread({}, projection.options), {}, {\n          onExitComplete: function onExitComplete() {\n            return _this.safeToRemove();\n          }\n        }));\n      }\n      globalProjectionState.hasEverUpdated = true;\n    }\n  }, {\n    key: \"getSnapshotBeforeUpdate\",\n    value: function getSnapshotBeforeUpdate(prevProps) {\n      var _this2 = this;\n      var _this$props2 = this.props,\n        layoutDependency = _this$props2.layoutDependency,\n        visualElement = _this$props2.visualElement,\n        drag = _this$props2.drag,\n        isPresent = _this$props2.isPresent;\n      var projection = visualElement.projection;\n      if (!projection) return null;\n      /**\n       * TODO: We use this data in relegate to determine whether to\n       * promote a previous element. There's no guarantee its presence data\n       * will have updated by this point - if a bug like this arises it will\n       * have to be that we markForRelegation and then find a new lead some other way,\n       * perhaps in didUpdate\n       */\n      projection.isPresent = isPresent;\n      if (drag || prevProps.layoutDependency !== layoutDependency || layoutDependency === undefined) {\n        projection.willUpdate();\n      } else {\n        this.safeToRemove();\n      }\n      if (prevProps.isPresent !== isPresent) {\n        if (isPresent) {\n          projection.promote();\n        } else if (!projection.relegate()) {\n          /**\n           * If there's another stack member taking over from this one,\n           * it's in charge of the exit animation and therefore should\n           * be in charge of the safe to remove. Otherwise we call it here.\n           */\n          frame.postRender(function () {\n            var stack = projection.getStack();\n            if (!stack || !stack.members.length) {\n              _this2.safeToRemove();\n            }\n          });\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      var _this3 = this;\n      var projection = this.props.visualElement.projection;\n      if (projection) {\n        projection.root.didUpdate();\n        queueMicrotask(function () {\n          if (!projection.currentAnimation && projection.isLead()) {\n            _this3.safeToRemove();\n          }\n        });\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      var _this$props3 = this.props,\n        visualElement = _this$props3.visualElement,\n        layoutGroup = _this$props3.layoutGroup,\n        promoteContext = _this$props3.switchLayoutGroup;\n      var projection = visualElement.projection;\n      if (projection) {\n        projection.scheduleCheckAfterUnmount();\n        if (layoutGroup && layoutGroup.group) layoutGroup.group.remove(projection);\n        if (promoteContext && promoteContext.deregister) promoteContext.deregister(projection);\n      }\n    }\n  }, {\n    key: \"safeToRemove\",\n    value: function safeToRemove() {\n      var safeToRemove = this.props.safeToRemove;\n      safeToRemove && safeToRemove();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return null;\n    }\n  }]);\n  return MeasureLayoutWithContext;\n}(React__default.Component);\nfunction MeasureLayout(props) {\n  var _usePresence = usePresence(),\n    _usePresence2 = _slicedToArray(_usePresence, 2),\n    isPresent = _usePresence2[0],\n    safeToRemove = _usePresence2[1];\n  var layoutGroup = useContext(LayoutGroupContext);\n  return React__default.createElement(MeasureLayoutWithContext, _objectSpread(_objectSpread({}, props), {}, {\n    layoutGroup: layoutGroup,\n    switchLayoutGroup: useContext(SwitchLayoutGroupContext),\n    isPresent: isPresent,\n    safeToRemove: safeToRemove\n  }));\n}\nvar defaultScaleCorrectors = {\n  borderRadius: _objectSpread(_objectSpread({}, correctBorderRadius), {}, {\n    applyTo: [\"borderTopLeftRadius\", \"borderTopRightRadius\", \"borderBottomLeftRadius\", \"borderBottomRightRadius\"]\n  }),\n  borderTopLeftRadius: correctBorderRadius,\n  borderTopRightRadius: correctBorderRadius,\n  borderBottomLeftRadius: correctBorderRadius,\n  borderBottomRightRadius: correctBorderRadius,\n  boxShadow: correctBoxShadow\n};\nexport { MeasureLayout };","map":{"version":3,"names":["frame","React__default","useContext","usePresence","LayoutGroupContext","SwitchLayoutGroupContext","globalProjectionState","correctBorderRadius","correctBoxShadow","addScaleCorrector","MeasureLayoutWithContext","_React__default$Compo","_inherits","_super","_createSuper","_classCallCheck","apply","arguments","_createClass","key","value","componentDidMount","_this","_this$props","props","visualElement","layoutGroup","switchLayoutGroup","layoutId","projection","defaultScaleCorrectors","group","add","register","root","didUpdate","addEventListener","safeToRemove","setOptions","_objectSpread","options","onExitComplete","hasEverUpdated","getSnapshotBeforeUpdate","prevProps","_this2","_this$props2","layoutDependency","drag","isPresent","undefined","willUpdate","promote","relegate","postRender","stack","getStack","members","length","componentDidUpdate","_this3","queueMicrotask","currentAnimation","isLead","componentWillUnmount","_this$props3","promoteContext","scheduleCheckAfterUnmount","remove","deregister","render","Component","MeasureLayout","_usePresence","_usePresence2","_slicedToArray","createElement","borderRadius","applyTo","borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius","boxShadow"],"sources":["C:/Users/USER/Desktop/TicTacToeAI/node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs"],"sourcesContent":["import { frame } from '../../../frameloop/index.mjs';\nimport React__default, { useContext } from 'react';\nimport { usePresence } from '../../../components/AnimatePresence/use-presence.mjs';\nimport { LayoutGroupContext } from '../../../context/LayoutGroupContext.mjs';\nimport { SwitchLayoutGroupContext } from '../../../context/SwitchLayoutGroupContext.mjs';\nimport { globalProjectionState } from '../../../projection/node/state.mjs';\nimport { correctBorderRadius } from '../../../projection/styles/scale-border-radius.mjs';\nimport { correctBoxShadow } from '../../../projection/styles/scale-box-shadow.mjs';\nimport { addScaleCorrector } from '../../../projection/styles/scale-correction.mjs';\n\nclass MeasureLayoutWithContext extends React__default.Component {\n    /**\n     * This only mounts projection nodes for components that\n     * need measuring, we might want to do it for all components\n     * in order to incorporate transforms\n     */\n    componentDidMount() {\n        const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;\n        const { projection } = visualElement;\n        addScaleCorrector(defaultScaleCorrectors);\n        if (projection) {\n            if (layoutGroup.group)\n                layoutGroup.group.add(projection);\n            if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {\n                switchLayoutGroup.register(projection);\n            }\n            projection.root.didUpdate();\n            projection.addEventListener(\"animationComplete\", () => {\n                this.safeToRemove();\n            });\n            projection.setOptions({\n                ...projection.options,\n                onExitComplete: () => this.safeToRemove(),\n            });\n        }\n        globalProjectionState.hasEverUpdated = true;\n    }\n    getSnapshotBeforeUpdate(prevProps) {\n        const { layoutDependency, visualElement, drag, isPresent } = this.props;\n        const projection = visualElement.projection;\n        if (!projection)\n            return null;\n        /**\n         * TODO: We use this data in relegate to determine whether to\n         * promote a previous element. There's no guarantee its presence data\n         * will have updated by this point - if a bug like this arises it will\n         * have to be that we markForRelegation and then find a new lead some other way,\n         * perhaps in didUpdate\n         */\n        projection.isPresent = isPresent;\n        if (drag ||\n            prevProps.layoutDependency !== layoutDependency ||\n            layoutDependency === undefined) {\n            projection.willUpdate();\n        }\n        else {\n            this.safeToRemove();\n        }\n        if (prevProps.isPresent !== isPresent) {\n            if (isPresent) {\n                projection.promote();\n            }\n            else if (!projection.relegate()) {\n                /**\n                 * If there's another stack member taking over from this one,\n                 * it's in charge of the exit animation and therefore should\n                 * be in charge of the safe to remove. Otherwise we call it here.\n                 */\n                frame.postRender(() => {\n                    const stack = projection.getStack();\n                    if (!stack || !stack.members.length) {\n                        this.safeToRemove();\n                    }\n                });\n            }\n        }\n        return null;\n    }\n    componentDidUpdate() {\n        const { projection } = this.props.visualElement;\n        if (projection) {\n            projection.root.didUpdate();\n            queueMicrotask(() => {\n                if (!projection.currentAnimation && projection.isLead()) {\n                    this.safeToRemove();\n                }\n            });\n        }\n    }\n    componentWillUnmount() {\n        const { visualElement, layoutGroup, switchLayoutGroup: promoteContext, } = this.props;\n        const { projection } = visualElement;\n        if (projection) {\n            projection.scheduleCheckAfterUnmount();\n            if (layoutGroup && layoutGroup.group)\n                layoutGroup.group.remove(projection);\n            if (promoteContext && promoteContext.deregister)\n                promoteContext.deregister(projection);\n        }\n    }\n    safeToRemove() {\n        const { safeToRemove } = this.props;\n        safeToRemove && safeToRemove();\n    }\n    render() {\n        return null;\n    }\n}\nfunction MeasureLayout(props) {\n    const [isPresent, safeToRemove] = usePresence();\n    const layoutGroup = useContext(LayoutGroupContext);\n    return (React__default.createElement(MeasureLayoutWithContext, { ...props, layoutGroup: layoutGroup, switchLayoutGroup: useContext(SwitchLayoutGroupContext), isPresent: isPresent, safeToRemove: safeToRemove }));\n}\nconst defaultScaleCorrectors = {\n    borderRadius: {\n        ...correctBorderRadius,\n        applyTo: [\n            \"borderTopLeftRadius\",\n            \"borderTopRightRadius\",\n            \"borderBottomLeftRadius\",\n            \"borderBottomRightRadius\",\n        ],\n    },\n    borderTopLeftRadius: correctBorderRadius,\n    borderTopRightRadius: correctBorderRadius,\n    borderBottomLeftRadius: correctBorderRadius,\n    borderBottomRightRadius: correctBorderRadius,\n    boxShadow: correctBoxShadow,\n};\n\nexport { MeasureLayout };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}