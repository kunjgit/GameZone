{"ast":null,"code":"import _objectWithoutProperties from \"C:/Users/USER/Desktop/TicTacToeAI/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"C:/Users/USER/Desktop/TicTacToeAI/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nvar _excluded = [\"keyframes\", \"restDelta\", \"restSpeed\"];\nimport { millisecondsToSeconds } from '../../../utils/time-conversion.mjs';\nimport { calcGeneratorVelocity } from '../utils/velocity.mjs';\nimport { findSpring, calcAngularFreq } from './find.mjs';\nvar durationKeys = [\"duration\", \"bounce\"];\nvar physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys) {\n  return keys.some(function (key) {\n    return options[key] !== undefined;\n  });\n}\nfunction getSpringOptions(options) {\n  var springOptions = _objectSpread({\n    velocity: 0.0,\n    stiffness: 100,\n    damping: 10,\n    mass: 1.0,\n    isResolvedFromDuration: false\n  }, options);\n  // stiffness/damping/mass overrides duration/bounce\n  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {\n    var derived = findSpring(options);\n    springOptions = _objectSpread(_objectSpread(_objectSpread({}, springOptions), derived), {}, {\n      velocity: 0.0,\n      mass: 1.0\n    });\n    springOptions.isResolvedFromDuration = true;\n  }\n  return springOptions;\n}\nfunction spring(_ref) {\n  var keyframes = _ref.keyframes,\n    restDelta = _ref.restDelta,\n    restSpeed = _ref.restSpeed,\n    options = _objectWithoutProperties(_ref, _excluded);\n  var origin = keyframes[0];\n  var target = keyframes[keyframes.length - 1];\n  /**\n   * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n   * to reduce GC during animation.\n   */\n  var state = {\n    done: false,\n    value: origin\n  };\n  var _getSpringOptions = getSpringOptions(options),\n    stiffness = _getSpringOptions.stiffness,\n    damping = _getSpringOptions.damping,\n    mass = _getSpringOptions.mass,\n    velocity = _getSpringOptions.velocity,\n    duration = _getSpringOptions.duration,\n    isResolvedFromDuration = _getSpringOptions.isResolvedFromDuration;\n  var initialVelocity = velocity ? -millisecondsToSeconds(velocity) : 0.0;\n  var dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n  var initialDelta = target - origin;\n  var undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));\n  /**\n   * If we're working on a granular scale, use smaller defaults for determining\n   * when the spring is finished.\n   *\n   * These defaults have been selected emprically based on what strikes a good\n   * ratio between feeling good and finishing as soon as changes are imperceptible.\n   */\n  var isGranularScale = Math.abs(initialDelta) < 5;\n  restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);\n  restDelta || (restDelta = isGranularScale ? 0.005 : 0.5);\n  var resolveSpring;\n  if (dampingRatio < 1) {\n    var angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n    // Underdamped spring\n    resolveSpring = function resolveSpring(t) {\n      var envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));\n    };\n  } else if (dampingRatio === 1) {\n    // Critically damped spring\n    resolveSpring = function resolveSpring(t) {\n      return target - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    };\n  } else {\n    // Overdamped spring\n    var dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n    resolveSpring = function resolveSpring(t) {\n      var envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n      // When performing sinh or cosh values can hit Infinity so we cap them here\n      var freqForT = Math.min(dampedAngularFreq * t, 300);\n      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;\n    };\n  }\n  return {\n    calculatedDuration: isResolvedFromDuration ? duration || null : null,\n    next: function next(t) {\n      var current = resolveSpring(t);\n      if (!isResolvedFromDuration) {\n        var currentVelocity = initialVelocity;\n        if (t !== 0) {\n          /**\n           * We only need to calculate velocity for under-damped springs\n           * as over- and critically-damped springs can't overshoot, so\n           * checking only for displacement is enough.\n           */\n          if (dampingRatio < 1) {\n            currentVelocity = calcGeneratorVelocity(resolveSpring, t, current);\n          } else {\n            currentVelocity = 0;\n          }\n        }\n        var isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n        var isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\n        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;\n      } else {\n        state.done = t >= duration;\n      }\n      state.value = state.done ? target : current;\n      return state;\n    }\n  };\n}\nexport { spring };","map":{"version":3,"names":["millisecondsToSeconds","calcGeneratorVelocity","findSpring","calcAngularFreq","durationKeys","physicsKeys","isSpringType","options","keys","some","key","undefined","getSpringOptions","springOptions","_objectSpread","velocity","stiffness","damping","mass","isResolvedFromDuration","derived","spring","_ref","keyframes","restDelta","restSpeed","_objectWithoutProperties","_excluded","origin","target","length","state","done","value","_getSpringOptions","duration","initialVelocity","dampingRatio","Math","sqrt","initialDelta","undampedAngularFreq","isGranularScale","abs","resolveSpring","angularFreq","t","envelope","exp","sin","cos","dampedAngularFreq","freqForT","min","sinh","cosh","calculatedDuration","next","current","currentVelocity","isBelowVelocityThreshold","isBelowDisplacementThreshold"],"sources":["C:/Users/USER/Desktop/TicTacToeAI/node_modules/framer-motion/dist/es/animation/generators/spring/index.mjs"],"sourcesContent":["import { millisecondsToSeconds } from '../../../utils/time-conversion.mjs';\nimport { calcGeneratorVelocity } from '../utils/velocity.mjs';\nimport { findSpring, calcAngularFreq } from './find.mjs';\n\nconst durationKeys = [\"duration\", \"bounce\"];\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys) {\n    return keys.some((key) => options[key] !== undefined);\n}\nfunction getSpringOptions(options) {\n    let springOptions = {\n        velocity: 0.0,\n        stiffness: 100,\n        damping: 10,\n        mass: 1.0,\n        isResolvedFromDuration: false,\n        ...options,\n    };\n    // stiffness/damping/mass overrides duration/bounce\n    if (!isSpringType(options, physicsKeys) &&\n        isSpringType(options, durationKeys)) {\n        const derived = findSpring(options);\n        springOptions = {\n            ...springOptions,\n            ...derived,\n            velocity: 0.0,\n            mass: 1.0,\n        };\n        springOptions.isResolvedFromDuration = true;\n    }\n    return springOptions;\n}\nfunction spring({ keyframes, restDelta, restSpeed, ...options }) {\n    const origin = keyframes[0];\n    const target = keyframes[keyframes.length - 1];\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = { done: false, value: origin };\n    const { stiffness, damping, mass, velocity, duration, isResolvedFromDuration, } = getSpringOptions(options);\n    const initialVelocity = velocity ? -millisecondsToSeconds(velocity) : 0.0;\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n    const initialDelta = target - origin;\n    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));\n    /**\n     * If we're working on a granular scale, use smaller defaults for determining\n     * when the spring is finished.\n     *\n     * These defaults have been selected emprically based on what strikes a good\n     * ratio between feeling good and finishing as soon as changes are imperceptible.\n     */\n    const isGranularScale = Math.abs(initialDelta) < 5;\n    restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);\n    restDelta || (restDelta = isGranularScale ? 0.005 : 0.5);\n    let resolveSpring;\n    if (dampingRatio < 1) {\n        const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n        // Underdamped spring\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            return (target -\n                envelope *\n                    (((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) /\n                        angularFreq) *\n                        Math.sin(angularFreq * t) +\n                        initialDelta * Math.cos(angularFreq * t)));\n        };\n    }\n    else if (dampingRatio === 1) {\n        // Critically damped spring\n        resolveSpring = (t) => target -\n            Math.exp(-undampedAngularFreq * t) *\n                (initialDelta +\n                    (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    }\n    else {\n        // Overdamped spring\n        const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            // When performing sinh or cosh values can hit Infinity so we cap them here\n            const freqForT = Math.min(dampedAngularFreq * t, 300);\n            return (target -\n                (envelope *\n                    ((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) *\n                        Math.sinh(freqForT) +\n                        dampedAngularFreq *\n                            initialDelta *\n                            Math.cosh(freqForT))) /\n                    dampedAngularFreq);\n        };\n    }\n    return {\n        calculatedDuration: isResolvedFromDuration ? duration || null : null,\n        next: (t) => {\n            const current = resolveSpring(t);\n            if (!isResolvedFromDuration) {\n                let currentVelocity = initialVelocity;\n                if (t !== 0) {\n                    /**\n                     * We only need to calculate velocity for under-damped springs\n                     * as over- and critically-damped springs can't overshoot, so\n                     * checking only for displacement is enough.\n                     */\n                    if (dampingRatio < 1) {\n                        currentVelocity = calcGeneratorVelocity(resolveSpring, t, current);\n                    }\n                    else {\n                        currentVelocity = 0;\n                    }\n                }\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n                const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\n                state.done =\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\n            }\n            else {\n                state.done = t >= duration;\n            }\n            state.value = state.done ? target : current;\n            return state;\n        },\n    };\n}\n\nexport { spring };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}