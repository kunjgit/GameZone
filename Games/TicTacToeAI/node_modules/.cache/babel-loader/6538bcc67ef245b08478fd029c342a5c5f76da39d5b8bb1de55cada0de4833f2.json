{"ast":null,"code":"import _slicedToArray from \"C:/Users/USER/Desktop/TicTacToeAI/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"C:/Users/USER/Desktop/TicTacToeAI/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { isKeyframesTarget } from '../../../animation/utils/is-keyframes-target.mjs';\nimport { invariant } from '../../../utils/errors.mjs';\nimport { transformPropOrder } from '../../html/utils/transform.mjs';\nimport { findDimensionValueType } from '../value-types/dimensions.mjs';\nimport { isBrowser } from '../../../utils/is-browser.mjs';\nimport { number } from '../../../value/types/numbers/index.mjs';\nimport { px } from '../../../value/types/numbers/units.mjs';\nvar positionalKeys = new Set([\"width\", \"height\", \"top\", \"left\", \"right\", \"bottom\", \"x\", \"y\", \"translateX\", \"translateY\"]);\nvar isPositionalKey = function isPositionalKey(key) {\n  return positionalKeys.has(key);\n};\nvar hasPositionalKey = function hasPositionalKey(target) {\n  return Object.keys(target).some(isPositionalKey);\n};\nvar isNumOrPxType = function isNumOrPxType(v) {\n  return v === number || v === px;\n};\nvar getPosFromMatrix = function getPosFromMatrix(matrix, pos) {\n  return parseFloat(matrix.split(\", \")[pos]);\n};\nvar getTranslateFromMatrix = function getTranslateFromMatrix(pos2, pos3) {\n  return function (_bbox, _ref) {\n    var transform = _ref.transform;\n    if (transform === \"none\" || !transform) return 0;\n    var matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\n    if (matrix3d) {\n      return getPosFromMatrix(matrix3d[1], pos3);\n    } else {\n      var matrix = transform.match(/^matrix\\((.+)\\)$/);\n      if (matrix) {\n        return getPosFromMatrix(matrix[1], pos2);\n      } else {\n        return 0;\n      }\n    }\n  };\n};\nvar transformKeys = new Set([\"x\", \"y\", \"z\"]);\nvar nonTranslationalTransformKeys = transformPropOrder.filter(function (key) {\n  return !transformKeys.has(key);\n});\nfunction removeNonTranslationalTransform(visualElement) {\n  var removedTransforms = [];\n  nonTranslationalTransformKeys.forEach(function (key) {\n    var value = visualElement.getValue(key);\n    if (value !== undefined) {\n      removedTransforms.push([key, value.get()]);\n      value.set(key.startsWith(\"scale\") ? 1 : 0);\n    }\n  });\n  // Apply changes to element before measurement\n  if (removedTransforms.length) visualElement.render();\n  return removedTransforms;\n}\nvar positionalValues = {\n  // Dimensions\n  width: function width(_ref2, _ref3) {\n    var x = _ref2.x;\n    var _ref3$paddingLeft = _ref3.paddingLeft,\n      paddingLeft = _ref3$paddingLeft === void 0 ? \"0\" : _ref3$paddingLeft,\n      _ref3$paddingRight = _ref3.paddingRight,\n      paddingRight = _ref3$paddingRight === void 0 ? \"0\" : _ref3$paddingRight;\n    return x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight);\n  },\n  height: function height(_ref4, _ref5) {\n    var y = _ref4.y;\n    var _ref5$paddingTop = _ref5.paddingTop,\n      paddingTop = _ref5$paddingTop === void 0 ? \"0\" : _ref5$paddingTop,\n      _ref5$paddingBottom = _ref5.paddingBottom,\n      paddingBottom = _ref5$paddingBottom === void 0 ? \"0\" : _ref5$paddingBottom;\n    return y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom);\n  },\n  top: function top(_bbox, _ref6) {\n    var _top = _ref6.top;\n    return parseFloat(_top);\n  },\n  left: function left(_bbox, _ref7) {\n    var _left = _ref7.left;\n    return parseFloat(_left);\n  },\n  bottom: function bottom(_ref8, _ref9) {\n    var y = _ref8.y;\n    var top = _ref9.top;\n    return parseFloat(top) + (y.max - y.min);\n  },\n  right: function right(_ref10, _ref11) {\n    var x = _ref10.x;\n    var left = _ref11.left;\n    return parseFloat(left) + (x.max - x.min);\n  },\n  // Transform\n  x: getTranslateFromMatrix(4, 13),\n  y: getTranslateFromMatrix(5, 14)\n};\nvar convertChangedValueTypes = function convertChangedValueTypes(target, visualElement, changedKeys) {\n  var originBbox = visualElement.measureViewportBox();\n  var element = visualElement.current;\n  var elementComputedStyle = getComputedStyle(element);\n  var display = elementComputedStyle.display;\n  var origin = {};\n  // If the element is currently set to display: \"none\", make it visible before\n  // measuring the target bounding box\n  if (display === \"none\") {\n    visualElement.setStaticValue(\"display\", target.display || \"block\");\n  }\n  /**\n   * Record origins before we render and update styles\n   */\n  changedKeys.forEach(function (key) {\n    origin[key] = positionalValues[key](originBbox, elementComputedStyle);\n  });\n  // Apply the latest values (as set in checkAndConvertChangedValueTypes)\n  visualElement.render();\n  var targetBbox = visualElement.measureViewportBox();\n  changedKeys.forEach(function (key) {\n    // Restore styles to their **calculated computed style**, not their actual\n    // originally set style. This allows us to animate between equivalent pixel units.\n    var value = visualElement.getValue(key);\n    value && value.jump(origin[key]);\n    target[key] = positionalValues[key](targetBbox, elementComputedStyle);\n  });\n  return target;\n};\nvar checkAndConvertChangedValueTypes = function checkAndConvertChangedValueTypes(visualElement, target) {\n  var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var transitionEnd = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  target = _objectSpread({}, target);\n  transitionEnd = _objectSpread({}, transitionEnd);\n  var targetPositionalKeys = Object.keys(target).filter(isPositionalKey);\n  // We want to remove any transform values that could affect the element's bounding box before\n  // it's measured. We'll reapply these later.\n  var removedTransformValues = [];\n  var hasAttemptedToRemoveTransformValues = false;\n  var changedValueTypeKeys = [];\n  targetPositionalKeys.forEach(function (key) {\n    var value = visualElement.getValue(key);\n    if (!visualElement.hasValue(key)) return;\n    var from = origin[key];\n    var fromType = findDimensionValueType(from);\n    var to = target[key];\n    var toType;\n    // TODO: The current implementation of this basically throws an error\n    // if you try and do value conversion via keyframes. There's probably\n    // a way of doing this but the performance implications would need greater scrutiny,\n    // as it'd be doing multiple resize-remeasure operations.\n    if (isKeyframesTarget(to)) {\n      var numKeyframes = to.length;\n      var fromIndex = to[0] === null ? 1 : 0;\n      from = to[fromIndex];\n      fromType = findDimensionValueType(from);\n      for (var i = fromIndex; i < numKeyframes; i++) {\n        /**\n         * Don't allow wildcard keyframes to be used to detect\n         * a difference in value types.\n         */\n        if (to[i] === null) break;\n        if (!toType) {\n          toType = findDimensionValueType(to[i]);\n          invariant(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), \"Keyframes must be of the same dimension as the current value\");\n        } else {\n          invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\n        }\n      }\n    } else {\n      toType = findDimensionValueType(to);\n    }\n    if (fromType !== toType) {\n      // If they're both just number or px, convert them both to numbers rather than\n      // relying on resize/remeasure to convert (which is wasteful in this situation)\n      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n        var current = value.get();\n        if (typeof current === \"string\") {\n          value.set(parseFloat(current));\n        }\n        if (typeof to === \"string\") {\n          target[key] = parseFloat(to);\n        } else if (Array.isArray(to) && toType === px) {\n          target[key] = to.map(parseFloat);\n        }\n      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from === 0 || to === 0)) {\n        // If one or the other value is 0, it's safe to coerce it to the\n        // type of the other without measurement\n        if (from === 0) {\n          value.set(toType.transform(from));\n        } else {\n          target[key] = fromType.transform(to);\n        }\n      } else {\n        // If we're going to do value conversion via DOM measurements, we first\n        // need to remove non-positional transform values that could affect the bbox measurements.\n        if (!hasAttemptedToRemoveTransformValues) {\n          removedTransformValues = removeNonTranslationalTransform(visualElement);\n          hasAttemptedToRemoveTransformValues = true;\n        }\n        changedValueTypeKeys.push(key);\n        transitionEnd[key] = transitionEnd[key] !== undefined ? transitionEnd[key] : target[key];\n        value.jump(to);\n      }\n    }\n  });\n  if (changedValueTypeKeys.length) {\n    var scrollY = changedValueTypeKeys.indexOf(\"height\") >= 0 ? window.pageYOffset : null;\n    var convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);\n    // If we removed transform values, reapply them before the next render\n    if (removedTransformValues.length) {\n      removedTransformValues.forEach(function (_ref12) {\n        var _ref13 = _slicedToArray(_ref12, 2),\n          key = _ref13[0],\n          value = _ref13[1];\n        visualElement.getValue(key).set(value);\n      });\n    }\n    // Reapply original values\n    visualElement.render();\n    // Restore scroll position\n    if (isBrowser && scrollY !== null) {\n      window.scrollTo({\n        top: scrollY\n      });\n    }\n    return {\n      target: convertedTarget,\n      transitionEnd: transitionEnd\n    };\n  } else {\n    return {\n      target: target,\n      transitionEnd: transitionEnd\n    };\n  }\n};\n/**\n * Convert value types for x/y/width/height/top/left/bottom/right\n *\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\n *\n * @internal\n */\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\n  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) : {\n    target: target,\n    transitionEnd: transitionEnd\n  };\n}\nexport { positionalValues, unitConversion };","map":{"version":3,"names":["isKeyframesTarget","invariant","transformPropOrder","findDimensionValueType","isBrowser","number","px","positionalKeys","Set","isPositionalKey","key","has","hasPositionalKey","target","Object","keys","some","isNumOrPxType","v","getPosFromMatrix","matrix","pos","parseFloat","split","getTranslateFromMatrix","pos2","pos3","_bbox","_ref","transform","matrix3d","match","transformKeys","nonTranslationalTransformKeys","filter","removeNonTranslationalTransform","visualElement","removedTransforms","forEach","value","getValue","undefined","push","get","set","startsWith","length","render","positionalValues","width","_ref2","_ref3","x","_ref3$paddingLeft","paddingLeft","_ref3$paddingRight","paddingRight","max","min","height","_ref4","_ref5","y","_ref5$paddingTop","paddingTop","_ref5$paddingBottom","paddingBottom","top","_ref6","left","_ref7","bottom","_ref8","_ref9","right","_ref10","_ref11","convertChangedValueTypes","changedKeys","originBbox","measureViewportBox","element","current","elementComputedStyle","getComputedStyle","display","origin","setStaticValue","targetBbox","jump","checkAndConvertChangedValueTypes","arguments","transitionEnd","_objectSpread","targetPositionalKeys","removedTransformValues","hasAttemptedToRemoveTransformValues","changedValueTypeKeys","hasValue","from","fromType","to","toType","numKeyframes","fromIndex","i","Array","isArray","map","scrollY","indexOf","window","pageYOffset","convertedTarget","_ref12","_ref13","_slicedToArray","scrollTo","unitConversion"],"sources":["C:/Users/USER/Desktop/TicTacToeAI/node_modules/framer-motion/dist/es/render/dom/utils/unit-conversion.mjs"],"sourcesContent":["import { isKeyframesTarget } from '../../../animation/utils/is-keyframes-target.mjs';\nimport { invariant } from '../../../utils/errors.mjs';\nimport { transformPropOrder } from '../../html/utils/transform.mjs';\nimport { findDimensionValueType } from '../value-types/dimensions.mjs';\nimport { isBrowser } from '../../../utils/is-browser.mjs';\nimport { number } from '../../../value/types/numbers/index.mjs';\nimport { px } from '../../../value/types/numbers/units.mjs';\n\nconst positionalKeys = new Set([\n    \"width\",\n    \"height\",\n    \"top\",\n    \"left\",\n    \"right\",\n    \"bottom\",\n    \"x\",\n    \"y\",\n    \"translateX\",\n    \"translateY\",\n]);\nconst isPositionalKey = (key) => positionalKeys.has(key);\nconst hasPositionalKey = (target) => {\n    return Object.keys(target).some(isPositionalKey);\n};\nconst isNumOrPxType = (v) => v === number || v === px;\nconst getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(\", \")[pos]);\nconst getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform }) => {\n    if (transform === \"none\" || !transform)\n        return 0;\n    const matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\n    if (matrix3d) {\n        return getPosFromMatrix(matrix3d[1], pos3);\n    }\n    else {\n        const matrix = transform.match(/^matrix\\((.+)\\)$/);\n        if (matrix) {\n            return getPosFromMatrix(matrix[1], pos2);\n        }\n        else {\n            return 0;\n        }\n    }\n};\nconst transformKeys = new Set([\"x\", \"y\", \"z\"]);\nconst nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));\nfunction removeNonTranslationalTransform(visualElement) {\n    const removedTransforms = [];\n    nonTranslationalTransformKeys.forEach((key) => {\n        const value = visualElement.getValue(key);\n        if (value !== undefined) {\n            removedTransforms.push([key, value.get()]);\n            value.set(key.startsWith(\"scale\") ? 1 : 0);\n        }\n    });\n    // Apply changes to element before measurement\n    if (removedTransforms.length)\n        visualElement.render();\n    return removedTransforms;\n}\nconst positionalValues = {\n    // Dimensions\n    width: ({ x }, { paddingLeft = \"0\", paddingRight = \"0\" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),\n    height: ({ y }, { paddingTop = \"0\", paddingBottom = \"0\" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),\n    top: (_bbox, { top }) => parseFloat(top),\n    left: (_bbox, { left }) => parseFloat(left),\n    bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),\n    right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),\n    // Transform\n    x: getTranslateFromMatrix(4, 13),\n    y: getTranslateFromMatrix(5, 14),\n};\nconst convertChangedValueTypes = (target, visualElement, changedKeys) => {\n    const originBbox = visualElement.measureViewportBox();\n    const element = visualElement.current;\n    const elementComputedStyle = getComputedStyle(element);\n    const { display } = elementComputedStyle;\n    const origin = {};\n    // If the element is currently set to display: \"none\", make it visible before\n    // measuring the target bounding box\n    if (display === \"none\") {\n        visualElement.setStaticValue(\"display\", target.display || \"block\");\n    }\n    /**\n     * Record origins before we render and update styles\n     */\n    changedKeys.forEach((key) => {\n        origin[key] = positionalValues[key](originBbox, elementComputedStyle);\n    });\n    // Apply the latest values (as set in checkAndConvertChangedValueTypes)\n    visualElement.render();\n    const targetBbox = visualElement.measureViewportBox();\n    changedKeys.forEach((key) => {\n        // Restore styles to their **calculated computed style**, not their actual\n        // originally set style. This allows us to animate between equivalent pixel units.\n        const value = visualElement.getValue(key);\n        value && value.jump(origin[key]);\n        target[key] = positionalValues[key](targetBbox, elementComputedStyle);\n    });\n    return target;\n};\nconst checkAndConvertChangedValueTypes = (visualElement, target, origin = {}, transitionEnd = {}) => {\n    target = { ...target };\n    transitionEnd = { ...transitionEnd };\n    const targetPositionalKeys = Object.keys(target).filter(isPositionalKey);\n    // We want to remove any transform values that could affect the element's bounding box before\n    // it's measured. We'll reapply these later.\n    let removedTransformValues = [];\n    let hasAttemptedToRemoveTransformValues = false;\n    const changedValueTypeKeys = [];\n    targetPositionalKeys.forEach((key) => {\n        const value = visualElement.getValue(key);\n        if (!visualElement.hasValue(key))\n            return;\n        let from = origin[key];\n        let fromType = findDimensionValueType(from);\n        const to = target[key];\n        let toType;\n        // TODO: The current implementation of this basically throws an error\n        // if you try and do value conversion via keyframes. There's probably\n        // a way of doing this but the performance implications would need greater scrutiny,\n        // as it'd be doing multiple resize-remeasure operations.\n        if (isKeyframesTarget(to)) {\n            const numKeyframes = to.length;\n            const fromIndex = to[0] === null ? 1 : 0;\n            from = to[fromIndex];\n            fromType = findDimensionValueType(from);\n            for (let i = fromIndex; i < numKeyframes; i++) {\n                /**\n                 * Don't allow wildcard keyframes to be used to detect\n                 * a difference in value types.\n                 */\n                if (to[i] === null)\n                    break;\n                if (!toType) {\n                    toType = findDimensionValueType(to[i]);\n                    invariant(toType === fromType ||\n                        (isNumOrPxType(fromType) && isNumOrPxType(toType)), \"Keyframes must be of the same dimension as the current value\");\n                }\n                else {\n                    invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\n                }\n            }\n        }\n        else {\n            toType = findDimensionValueType(to);\n        }\n        if (fromType !== toType) {\n            // If they're both just number or px, convert them both to numbers rather than\n            // relying on resize/remeasure to convert (which is wasteful in this situation)\n            if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n                const current = value.get();\n                if (typeof current === \"string\") {\n                    value.set(parseFloat(current));\n                }\n                if (typeof to === \"string\") {\n                    target[key] = parseFloat(to);\n                }\n                else if (Array.isArray(to) && toType === px) {\n                    target[key] = to.map(parseFloat);\n                }\n            }\n            else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) &&\n                (toType === null || toType === void 0 ? void 0 : toType.transform) &&\n                (from === 0 || to === 0)) {\n                // If one or the other value is 0, it's safe to coerce it to the\n                // type of the other without measurement\n                if (from === 0) {\n                    value.set(toType.transform(from));\n                }\n                else {\n                    target[key] = fromType.transform(to);\n                }\n            }\n            else {\n                // If we're going to do value conversion via DOM measurements, we first\n                // need to remove non-positional transform values that could affect the bbox measurements.\n                if (!hasAttemptedToRemoveTransformValues) {\n                    removedTransformValues =\n                        removeNonTranslationalTransform(visualElement);\n                    hasAttemptedToRemoveTransformValues = true;\n                }\n                changedValueTypeKeys.push(key);\n                transitionEnd[key] =\n                    transitionEnd[key] !== undefined\n                        ? transitionEnd[key]\n                        : target[key];\n                value.jump(to);\n            }\n        }\n    });\n    if (changedValueTypeKeys.length) {\n        const scrollY = changedValueTypeKeys.indexOf(\"height\") >= 0\n            ? window.pageYOffset\n            : null;\n        const convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);\n        // If we removed transform values, reapply them before the next render\n        if (removedTransformValues.length) {\n            removedTransformValues.forEach(([key, value]) => {\n                visualElement.getValue(key).set(value);\n            });\n        }\n        // Reapply original values\n        visualElement.render();\n        // Restore scroll position\n        if (isBrowser && scrollY !== null) {\n            window.scrollTo({ top: scrollY });\n        }\n        return { target: convertedTarget, transitionEnd };\n    }\n    else {\n        return { target, transitionEnd };\n    }\n};\n/**\n * Convert value types for x/y/width/height/top/left/bottom/right\n *\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\n *\n * @internal\n */\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\n    return hasPositionalKey(target)\n        ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd)\n        : { target, transitionEnd };\n}\n\nexport { positionalValues, unitConversion };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}