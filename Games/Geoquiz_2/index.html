<meta charset=iso-8859-1>
<title>Geoquiz2</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="mobile-web-app-capable" content="yes">
<meta name="format-detection" content="telephone=no">
<meta name="msapplication-tap-highlight" content="no">

<body id=b>
<canvas id=a height=575>

<script>


// Note: this file is encoded in ANSI, in order to encode every byte of the game's data on a 1-byte char.

// These globals are just to inform the minifier what a, b and C-M are. Don't put them in the final file.

//b=document.body;
//a=document.createElement("canvas");
//C=D=E=F=G=H=I=J=K=L=M="";


// DATA (binary)
// =============

// countries 
C = `ï¿½2ï¿½L22|}c	,I9h_br"):
+CTAKBKBLRK9OOKAROVa1LaJaJ,IZrDIyMT)IrJZA:GZnyIk	qiqczï¿½5Jï¿½Qï¿½
Aï¿½
@ï¿½6n#+ZCY	Aï¿½CQJTï¿½H ï¿½JXï¿½\rAJaï¿½Pï¿½xï¿½
~ï¿½Nï¿½7bQc[O:B;R[jSrj
jzy%:I9
%Q;1ï¿½mhX8~KE=?sa 
!qa8I8 AY!1A39aQ2BJrYiQqa:)ID0A#(
"Ja:a2AKiXzY)AqXKARJAIAMSCoi	y}izHz(U-J	A1IK80*
.\ryQ0	@6
z0@Q6
P<RIWJSxOJ<	
YDRqbRz19
D;BDaG$XHLP8"5z1Y:qzL~ï¿½?ï¿½;a8PpIppXi
+ï¿½Jh0~ï¿½T{c02bsjyV~Wï¿½Wï¿½#S!Femcor"1#
!Pï¿½i
~ï¿½ï¿½lD!KaA^Tku
{hr&4ï¿½ï¿½r)~ï¿½@ï¿½C!JZ~ï¿½;ï¿½;8~_ï¿½[ï¿½)#*;KE*U*WjQb{ivz[~ï¿½Jï¿½L	(@Ji~ï¿½gï¿½eRy	~Oï¿½Oï¿½ucmcoziyD3*#+#*~ï¿½Dï¿½CpIq:~FiFi	PI0IA~ï¿½=ï¿½?0Y~ï¿½3ï¿½4P0(i	h~Iï¿½Iï¿½9)~ï¿½^ï¿½jO.	qa1~ï¿½+ï¿½+z @I~ï¿½*ï¿½*y,OU
]Sk~ï¿½)ï¿½)	3)@QJsRiy~ï¿½8ï¿½6ch
02A~ï¿½Rï¿½RHy(9 XIQhpï¿½VHP	~ï¿½Aï¿½AQhIA~}Nï¿½JxZbJ@ (!I(
x~ï¿½Bï¿½AY
~ï¿½:ï¿½;IQH"H9!a	Yqy{5p~q"ox
zSC~ï¿½aï¿½\`Zb2IrR]ib96!Q0 @	:!1yai	
~Ì“Ì“X	L@KØ™ Ö™HË’A2=yiyÎˆ!	ixZhK1Õ’)y1I0
PIHhaÛ‡xh@Ý‹yq qX	+AY@1~ï¿½Vï¿½OQ@iya{qy
!9 29AYIA~ï¿½Yï¿½SyaqXIC((~|5|5qR00h~ï¿½\\ï¿½\`1 ~ï¿½Kï¿½K:Y) 	azh8XpXhA(ï¿½Mi(~JpJpH~ï¿½Vï¿½VQY@Qxa1	"qï¿½FYIX~ï¿½Yï¿½YPp~ï¿½4ï¿½50H 
xa~ï¿½=ï¿½=~ï¿½Kï¿½L0Pi~ï¿½ï¿½ï¿½ï¿½jaq	&2b~;n.[

z|jz	!cHhY9PF)>1Xq|P<(~ï¿½Hï¿½H~|X|X rUpK"~Wï¿½Wï¿½0)@!zhq~ï¿½Zï¿½\\AZDZpjy
~ï¿½bï¿½cJAI)~ï¿½9ï¿½7a	!~ï¿½ï¿½ï¿½ï¿½8 2{p^aJï¿½ï¿½Hx~ï¿½Pï¿½K	xZpY8 @~ï¿½\\ï¿½\\~Yï¿½Uï¿½1!
szS)~Jï¿½Pï¿½lHC59)yhQay~ï¿½uï¿½u0!iXqH9Xa2aY (	×€piPxH0~ï¿½8ï¿½5raJB2~zQzQy (!I~ï¿½Gï¿½H @ 0JQq~ï¿½fï¿½g8p~ï¿½gï¿½\`@yry	iUJ~ÊˆÊˆ~ï¿½@ï¿½@J~ï¿½Dï¿½C	a~ï¿½ï¿½ï¿½ï¿½)y!jcZQK9 1 ~ï¿½Sï¿½Spa(1~ï¿½+ï¿½+bQ2!* rIaZhy~ï¿½fï¿½fPi~ï¿½Tï¿½^2!ay~ï¿½Oï¿½K	yiQLPAXA1	@I~ï¿½<ï¿½=(ihYQQAAa@8@QH@~Yï¿½[ï¿½hYB#~JQJQ~Q{Q{zaxRpQ9!C)i8~ï¿½Kï¿½K~ï¿½lï¿½jpYzr\\)*: H~ï¿½Wï¿½_ 8)	x	xJpaPhHY~ï¿½Jï¿½J~ï¿½Lï¿½O0 i~ï¿½6ï¿½2hyPhXJA)~ï¿½Hï¿½Fxa@1~ï¿½x}xzYQJ~ï¿½ï¿½ï¿½ï¿½2}PJhAXH~ï¿½ï¿½ï¿½ï¿½ x#qHqXrPK ~ï¿½ï¿½ï¿½ï¿½&(
qYkqYqxH8HB)@XH9J~}ï¿½{ï¿½ 8!x	paxI~E|D{z 0@~Lï¿½Iï¿½*!hXhapYjB~Qï¿½Oï¿½")ihzPIaqCa~pupuor~ï¿½Vï¿½VXH~ï¿½ï¿½ï¿½ï¿½+yi~ï¿½ï¿½ï¿½ï¿½)0qah~ï¿½yï¿½{A(	i~UtUt~ï¿½ï¿½ï¿½ï¿½R0*~OpOp	Bi~ï¿½ï¿½ï¿½ï¿½jHY9~ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½p	8~Au?v(qX~MpNq)PpH~CvCw@IY~ï¿½[ï¿½[iIxY@~ï¿½;ï¿½C9!*
z|bIiIqNYA1Q:QjC0~ï¿½Jï¿½J@h~ï¿½\`ï¿½\` q~ï¿½pï¿½jYq	r)9(H~ï¿½ï¿½ï¿½ï¿½;+y
k~È…È…1	sÎˆyXIiR~{x}fPnKqz	!	+Q~ï¿½Uï¿½U~ï¿½Bï¿½AyY)~ï¿½Yï¿½e!A
(0
RqaXRzQ9~H}F}
yh9Q@~ï¿½Gï¿½G~uuyxK0!	~ï¿½Fï¿½JA)h~ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½~ï¿½ï¿½ï¿½yf\\+C ~ï¿½ï¿½ï¿½|j~ï¿½tï¿½}2,sf1Z~ï¿½ï¿½ï¿½ï¿½;Jkqy
~ï¿½wÇ1"3qrSaz~ï¿½tï¿½r
	qV~ï¿½ï¿½ï¿½ï¿½)BZ|~UqUq~ï¿½Nï¿½Lz9~ï¿½Nï¿½OP9	yY~ï¿½ï¿½ï¿½ï¿½td1)	(A)HXH9~JfJfKg~ï¿½dï¿½d~ï¿½hï¿½e	rI~WwWw~BqBs0~ï¿½cï¿½c
Q~ï¿½ï¿½ï¿½ï¿½
{[Ia1)~ÒƒÒƒ~ï¿½ï¿½ï¿½ï¿½p~ï¿½yï¿½|3#)iZrU1~ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½~ï¿½zï¿½z Y~BwBw0X~ï¿½}ï¿½vd|
C0(C~ï¿½tï¿½x<b~ï¿½ï¿½ï¿½ï¿½@hï¿½ï¿½h~uwuw	@~ï¿½Kï¿½Iq
A~ï¿½ï¿½ï¿½ï¿½*Qap~UyUy~w}w}0	zaA0~uyuxy~ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½~ï¿½Jï¿½JNXR~ï¿½/ï¿½1(	(Y@~ï¿½ï¿½ï¿½ï¿½xX~yï¿½xï¿½!ha~ï¿½Bï¿½B~ï¿½ï¿½ï¿½ï¿½*sa~ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½~ï¿½ï¿½ï¿½ï¿½ï¿½}~up}fPnK0I3
"
(~ï¿½ï¿½ï¿½ï¿½~ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½~ï¿½Aï¿½=a	yUYOE(:~ï¿½Jï¿½I@hq~ï¿½ï¿½ï¿½ï¿½*!)A(y1 
r]j~ï¿½nï¿½k"bzZsh3Q~ï¿½ï¿½ï¿½ï¿½jXkQ@7(~ï¿½ï¿½ï¿½ï¿½~DyD{1b~ï¿½wï¿½x1#)JTkIPq~ï¿½}ï¿½ï¿½ x#Oqah~ï¿½hï¿½oq":ai~ï¿½ï¿½ï¿½ï¿½(p~ï¿½ï¿½?Ik	ï¿½Y~ï¿½ï¿½ï¿½ï¿½@i~TqTq~VvVv~UwUw~ï¿½ï¿½~ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½~w}w}ha~ï¿½ï¿½x0ï¿½Pï¿½8ï¿½x@~ï¿½ï¿½ï¿½ï¿½9+[L|
~Zï¿½Zï¿½Ihq~ï¿½Yï¿½Yp)Jax~ï¿½Qï¿½S)qI@~Ù—Ù—	Q~ï¿½ï¿½ï¿½ï¿½~U{U{~ï¿½Rï¿½V=RBt~ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½~ï¿½ï¿½ï¿½ï¿½(
jJh@~ï¿½Mï¿½MSi@=R*zy~ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½h0~ï¿½ï¿½ï¿½ï¿½I1)	(2j\\~ï¿½ï¿½\rï¿½~	ï¿½	ï¿½
ï¿½~ï¿½ï¿½ï¿½ï¿½Px`.split("~"),

// us states 
D = `ï¿½ï¿½0Xï¿½P)~+=&OOWMrUsbW
a})>K9;Zx/PAHS8p~7X5Ur+~9l:eKjzs	+X=~:k:k},M~GrJpMm
 
~\\}X}sa:2Q~WhYclY;0~]i[k*ia~hghg(~_v]t
S~O}JplK}!}"+KA*~ckaj
qP(~ardpiQAQI~Bh@e
ykK~bndp1AaS~\`m_ic~chajI*rP~gfheIh	~Zy[}J+
~PgIf)sN(~HjDp,N~\\w_}K+	z~\\bYe2IY~LYITk+~AYITlO<(~Aw?y+mI~TtRw*cJ~g\`f^	bH~fhfh:rXq~fb\`dz,H~hbgc#k~hchcIh
~ekekh~OsRw+Mj~>a=e/i{	k~7^=\\lN-~ZjYek	+~SeUaLs~QkKijN~M_I\\jN~[nWq	 a~ZrWqZM~U}Uxi	iIA*~j^l^2Qk~S]PTn2"C~VyU|)	kP8~WaVc
*8R0Kar~UmRq;K~HeI^kN+`.split("~"),

// territories 
E = `_UOS{}w$*KC~Lï¿½y#[||ï¿½~{biJbJ"~}U~Us~ï¿½j~Vu~ï¿½ï¿½~ï¿½w~Gn~Tp~ï¿½ï¿½ï¿½ï¿½~}ï¿½~Tp~ï¿½ï¿½P9~RpPSq~ï¿½ï¿½ï¿½~Zï¿½i
9~=~ï¿½ï¿½ï¿½ï¿½~ï¿½ï¿½~YC~Tp~ï¿½~|&~S[~ï¿½ï¿½ï¿½ï¿½ï¿½	rb~ï¿½ï¿½XH p~Sp~Sq~OxPx~Ox~ï¿½)~fï¿½pnï¿½nï¿½~Qy~ï¿½ï¿½~Åœ~Px~Ë™~Wï¿½YVï¿½ h~ï¿½ï¿½~}5~>~ï¿½l~ï¿½r~Tr~ï¿½ï¿½~%ï¿½&ï¿½)ï¿½~{X~ï¿½~Nk~ï¿½CRJA`.split("~"),

// places
F = `Hacï¿½ï¿½Nï¿½]ï¿½?ï¿½Gï¿½Kï¿½9LMï¿½Nï¿½]ï¿½?ï¿½Qï¿½Kï¿½1ï¿½;ï¿½Eï¿½?ï¿½FJQ1Uï¿½G}TLM-XMMï¿½?KQï¿½F/S~NMLï¿½Kï¿½GNï¿½ï¿½fï¿½K+?ï¿½d*Rï¿½f*Rï¿½Pï¿½;ï¿½ï¿½ï¿½ï¿½1ï¿½ï¿½ï¿½Wï¿½\`ï¿½Kï¿½hÉ…3FIHï¿½\`ï¿½kï¿½;ï¿½:8FKQï¿½ï¿½ë»‚Kï¿½Mï¿½;4ï¿½GdCJï¿½ECJï¿½1ï¿½9ï¿½KMï¿½ï¿½ï¿½ï¿½Xï¿½wï¿½?ï¿½[Ó–Blï¿½Dï¿½LÝ­ï¿½8ï¿½S6Oï¿½Vï¿½]rï¿½ï¿½`.match(/.{2}/g),

// lakes
G = `ECQ0K~ï¿½D~CFbpI~Pï¿½8~ï¿½ï¿½a	)~(
QxI~ï¿½ï¿½qi1~3$R8Y~Dyp~}/~ï¿½t~ï¿½: paXQ~KGR
~ï¿½s~EDxi@~ï¿½ï¿½9)~FLX~<:9iqX~ï¿½'yP~ï¿½F(
XI~ï¿½"iy(8(~)I~ï¿½e~.:~+R~,=`.split("~"),

// streams 
H = `_ï¿½RBZKARA~ï¿½\\b{[qqY~ï¿½ï¿½#
vb~ï¿½ï¿½!;4R]~}Br~ï¿½ï¿½;JZ:*~ï¿½i*#~Ba;3!;(~0]+~'A$1y~Wï¿½"	~ï¿½]BZJAZR3D~ï¿½R[J+AbQIqJ~ï¿½k9IAQ!~ï¿½C!2*~ï¿½K:J9)M:~ï¿½6ky~ï¿½4r~ï¿½8zX~ï¿½J!0~ï¿½<y~ï¿½ï¿½y	~tp{aq~ï¿½ï¿½)A2~ï¿½vrz~tw~wa
9~}ï¿½1!~ï¿½ï¿½)9X~Wï¿½8*!~
(	!z{~hï¿½CQjd~ï¿½ï¿½1*8~ï¿½ï¿½3IY~=fB1B2"@~\`ï¿½ZrYjb~W|Ua~=b3@~ {r	~Lyiqb~(@	!3~dï¿½ZiP~OA[R~Qï¿½yy~Xï¿½aq~ï¿½k[rZKRA[Si~ï¿½5b[J=Jb~ï¿½}93:*3B~ï¿½}k|sYj~ï¿½Sj|Z{~ï¿½l)1(~ï¿½w*0+2C~ï¿½_B;A~ï¿½Fr{~ï¿½l3K: ~ï¿½M)B:~ï¿½t+$~ï¿½WaZK~ï¿½_<)A~ï¿½RbRs~ï¿½P;Ia~ï¿½t:IA~ï¿½u8IA~ï¿½k~ï¿½n1A~ï¿½!AQ~ï¿½E;"=B[:~ï¿½D<*~ï¿½D A3~ï¿½dzb	~ï¿½F2K~yR	~ï¿½3j~ï¿½.{	~ï¿½	y
~ï¿½Sx`.split("~"),

// deserts 
I = `ws3wWOOO~0W*zj~ï¿½av[U3~ï¿½N#[Ta~ß°K8Z~ï¿½3"|~Mï¿½t\\*!1 ~ï¿½\`+{~ß°K<~ï¿½ï¿½2 4{kr~4^<{kD:~ï¿½ï¿½jcB~Qï¿½9)1Elcs~ï¿½R:|R~2_0Iq;*|i~ï¿½O9r~ï¿½NjT~ï¿½i;j	~Ú®[:~ï¿½_
(y[I~ï¿½ds~0WB)~ï¿½YJ1~ï¿½_2
r`.split("~"),

// volcanoes
J = `ï¿½Rï¿½Lï¿½ï¿½Vus!*Bmï¿½OAtï¿½sï¿½ï¿½ï¿½vï¿½ Ï”ï¿½wAuï¿½ï¿½ï¿½Zï¿½ï¿½ï¿½nKï¿½Ë‘Ô–Lï¿½`.match(/.{2}/g),

// mountains
K=`ï¿½\`ï¿½Tï¿½\`ï¿½Uï¿½ï¿½ï¿½D;oï¿½Nï¿½Wï¿½Ì¾aï¿½aï¿½aï¿½\`ï¿½\`ï¿½Vï¿½Vï¿½Wï¿½aï¿½b"pNï¿½ï¿½Wï¿½Hï¿½D,R2FQï¿½ï¿½C~0+@Óï¿½^ï¿½\\/7`.match(/.{2}/g),

// forests 
L = `\\ï¿½COVn;$~Ë‘A2:ry~\r

|c{{,}RK^BI;OFOG<LET6ï¿½c
[<OMREOWOK[ODMWT4C~DH!xiCE0Kk
~-W:2)jz~ï¿½ï¿½*ubUD4dJ~ï¿½ï¿½"1i
j[KCY~Ó‚Y~ï¿½jR!
p~ï¿½1Zr~ï¿½h!yi~ï¿½7	yYA~ï¿½A!xi~ï¿½VI[}*~@q	b9~*zq!<~EtY~hï¿½iYciYaSj[:#y5~Pï¿½Zkbi#*`.split("~"),

// seas
M = `D/ 3?}F#I)L$AM7o$o:m/i;T#R&L.wP\r$:+.G>=C$D'd?gImNADR2W<N:m\`A
"#uo,f7j?kBl?kJmIpKycl,j(qP%* GM"F)I*F/J'I*Q<U4_;V	ky}	4}}}q\`p^,`.match(/[^]{3}/g);

// ONLOAD
// ======

// This onload function makes all the var names minifiable and waits for the fonts to load.
onload = () => {

// GLOBALS
// =======

// DATA
// ====

// by order of drawing:

// 0: seas
// 1: countries
// 2: us states
// 3: territories
// 4: deserts
// 5: forests
// 6: lakes
// 7: streams
// 8: capitals
// 9: us capitals
// 10: volcanoes
// 11: mountains
// 12: places
// 13: flags

var
datasets = window.dat = [

  // 0: seas
  [
    `SEA`,                  // dataset name
    
    // names
    `Mediterranean seaGulf of mexicoEnglish channelBering seaAdriatic seaAegean seaBlack seaNorth seaRed seaSea of japanPhilippine seaEast china seaSouth china seaAral seaCaspian seaDead seaCoral seaGulf of alaskaCaribbean seaSargasso seaBaltic seaIrish seaCeltic seaLigurian seaTyrrhenian seaGulf of thailandJava seaTimor seaGulf of guineaPersian gulfArabian seaBarents seaGreenland seaGreat australian bightNorwegian seaHudson bayJames baySea of okhotskSeto inland seaBeibu gulfSulu seaCelebes seaBohol seaFlores seaBanda seaArafura seaTasman seaYellow seaBohai seaGulf of carpentariaBaffin bayGulf of st lawrenceGulf of bothniaSea of azovIonian seaMirtoon seaGulf of sidraMarmara seaSea of creteGulf of adenGulf of omanBay of bengalKara seaBeaufort seaAmundsen gulfChukchi seaLaptev seaEast siberian seaAmundsen seaWeddell seaRoss seaGulf st vincentSpencer gulfSalton sea`.split(/(?=[A-Z])/),

    M,                      // center and radius for each sea (2b + 1b)
    [...Array(74).keys()],  // questions not asked yet (it's an array from 0 to N = 74)
    3,                      // how many bytes represent each item
    1,                      // fill color (0 = none, 1 = transparent = highlightable)
    0,                      // stroke color (0 = none)
    0,                      // start byte for the path
    1,                      // name group size
    0,                      // position in name group
    16,                     // diststep
  ],

  // 1: countries
  [
    `COUNTRY`,              // dataset name
    
    // names
    A=`RuRussiaMoscowCnChinaBeijingCaCanadaOttawaFrFranceParisDzAlgeriaAlgiersArArgentinaBuenos airesAuAustraliaCanberraAtAustriaViennaBeBelgiumBrusselsBrBrazilBrasiliaBgBulgariaSofiaAeUnited arab emiratesAbu dhabiClChileSantiagoHrCroatiaZagrebCuCubaHavanaCzCzechiaPragueDkDenmarkCopenhagenEcEcuadorQuitoEgEgyptCairoEeEstoniaTallinnNoNorwayOsloFiFinlandHelsinkiDeGermanyBerlinGrGreeceAthensHuHungaryBudapestEsSpainMadridChSwitzerlandBerneGbUnited kingdomLondonIsIcelandReykjavikInIndiaNew delhiIdIndonesiaJakartaIrIranTehranIqIraqBaghdadIeIrelandDublinIlIsraelJerusalemItItalyRomeJmJamaicaKingstonJpJapanTokyoLbLebanonBeirutLtLithuaniaVilniusLuLuxembourgLuxembourgMkMacedoniaSkopjeMgMadagascarAntananarivoMxMexicoMexico cityMcMonacoMonacoMaMoroccoRabatGyGuyanaGeorgetownLyLibyaTripoliNpNepalKathmanduNlNetherlandsAmsterdamNzNew zealandWellingtonKpNorth koreaPyongyangPsPalestineJerusalemPyParaguayAsuncionPePeruLimaPhPhilippinesManilaPlPolandWarsawPtPortugalLisbonRoRomaniaBucharestQaQatarDohaSaSaudi arabiaRiyadhSgSingaporeSingaporeSkSlovakiaBratislavaSiSloveniaLjubljanaZaSouth africaPretoriaKrSouth koreaSeoulSeSwedenStockholmTwTaiwanTaipeiTnTunisiaTunisTrTurkeyAnkaraUaUkraineKievUyUruguayMontevideoUsUsaWashington dcVeVenezuelaCaracasVaVatican cityVatican cityVnVietnamHanoiAfAfghanistanKabulAdAndorraAndorra la vellaAlAlbaniaTiranaByBelarusMinskBaBosniaSarajevoBfBurkina fasoOuagadougouCfCentral african republicBanguiCmCameroonYaoundeCdD.r.congoKinshasaCiCote d'ivoireYamoussoukroCrCosta ricaSan joseCoColombiaBogotaBoBoliviaLa pazCvCape verdePraiaCyCyprusNicosiaTgTogoLomeBjBeninPorto novoKhCambodiaPhnom penhDmDominicaRoseauCgCongoBrazzavilleDoDominican republicSanto domingoGaGabonLibrevilleGqEquatorial guineaMalaboGtGuatemalaGuatemala cityHtHaitiPort-au-princeHnHondurasTegucigalpaJoJordanAmmanKzKazakhstanAstanaXkKosovoPristinaKwKuwaitKuwait cityLaLaosVientianeKeKenyaNairobiMyMalaysiaKuala lumpurMlMaliBamakoMtMaltaVallettaMdMoldovaChisinauPkPakistanIslamabadPaPanamaPanama citySmSan marinoSan marinoSnSenegalDakarRsSerbiaBelgradeScSeychellesVictoriaSoSomaliaMogadishuLkSri lankaColomboSdSudanKhartoumTzTanzaniaDodomaThThailandBangkokYeYemenSanaaZwZimbabweHarareAgAntigua & barbudaSt john'sAmArmeniaYerevanAzAzerbaijanBakuAoAngolaLuandaBsBahamasNassauBhBahrainManamaBdBangladeshDhakaBbBarbadosBridgetownBzBelizeBelmopanBtBhutanThimphuBwBotswanaGaboroneBnBruneiBandar seri begawanBiBurundiBujumburaTdChadN'djamenaKmComorosMoroniDjDjiboutiDjiboutiSvEl salvadorSan salvadorEtEthiopiaAddis ababaErEritreaAsmaraFjFijiSuvaGmGambiaBanjulGeGeorgiaTbilisiGhGhanaAccraGdGrenadaSt george'sGnGuineaConakryGwGuinea-bissauBissauKiKiribatiTarawaKgKyrgyzstanBishkekLvLatviaRigaLsLesothoMaseruLrLiberiaMonroviaLiLiechtensteinVaduzMwMalawiLilongweMvMaldivesMaleMhMarshall islandsMajuroMrMauritaniaNouakchottMuMauritiusPort louisFmMicronesiaPalikirMnMongoliaUlan batorMeMontenegroPodgoricaMzMozambiqueMaputoMmMyanmarNaypyidawNaNamibiaWindhoekNrNauruYarenNiNicaraguaManaguaNeNigerNiameyNgNigeriaAbujaOmOmanMuscatPwPalauMelekeokPgPapua new guineaPort moresbyRwRwandaKigaliKnSt kitts & nevisBasseterreLcSt luciaCastriesVcSt vincent & grenadinesKingstownWsSamoaApiaStSao tome & principleSao tomeSlSierra leoneFreetownSbSolomon islandsHoniaraSsSouth sudanJubaSrSurinameParamariboSySyriaDamascusTjTajikistanDushanbeTlTimor-lesteDiliToTongaNuku'alofaTtTrinidad & tobagoPort of spainTmTurkmenistanAshgabatTvTuvaluFunafutiUgUgandaKampalaUzUzbekistanTashkentVuVanuatuPort vilaZmZambiaLusakaCkCook islandsAvaruaNuNiueAlofiSzSwazilandMbabane`.split(/(?=[A-Z])/),
    
    C,                      // polygons for each country (array of strings, 2b for capital + 2b + 1b per point)
    [...Array(199).keys()], // questions not asked yet (it's an array from 0 to N = 199)
    0,                      // how many bytes represent each item (0 = variable)
    `#080`,                 // fill color
    `#123`,                 // stroke color
    2,                      // start byte for the path
    3,                      // name group size
    1,                      // position in name group
    8,                      // diststep
  ],

  // 2: us states
  [
    `US STATE`,             // dataset name
    
    // names
    B=`HawaiiHonoluluAlaskaJuneauWashingtonOlympiaCaliforniaSacramentoNevadaCarson cityNew mexicoSanta feFloridaTallahasseeIllinoisSpringfieldOhioColumbusRhode islandProvidenceSouth carolinaColumbiaTexasAustinMarylandAnnapolisNorth carolinaRaleighUtahSalt lake cityVirginiaRichmondWest virginiaCharlestonPennsylvaniaHarrisburgConnecticutHartfordAlabamaMontgomeryNebraskaLincolnColoradoDenverGeorgiaAtlantaMichiganLansingNorth dakotaBismarckMontanaHelenaArizonaPhoenixArkansasLittle rockVermontMontpelierNew jerseyTrentonNew yorkAlbanyNew hampshireConcordMassachusettsBostonDelawareDoverOklahomaOklahoma cityIdahoBoiseOregonSalemIndianaIndianapolisIowaDes moinesKansasTopekaSouth dakotaPierreKentuckyFrankfortTennesseeNashvilleLouisianaBaton rougeMaineAugustaMinnesotaSt paulMississippiJacksonWisconsinMadisonMissouriJefferson cityWyomingCheyenne`.split(/(?=[A-Z])/),
    
    D,                      // polygons for each country (array of strings, 2b for capital + 2b + 1b per point)
    [...Array(50).keys()],  // questions not asked yet
    0,                      // how many bytes represent each item
    `#080`,                 // fill color
    `#123`,                 // stroke color
    2,                      // start byte for the path
    2,                      // name group size
    0,                      // position in name group
    6,                      // diststep
  ],

  // 3: territories
  [
    `TERRITORY`,            // dataset name
    
    // names
    `GreenlandAntarcticWestern saharaGibraltarGuadeloupeHong kongMartiniqueReunionGuamCayman islandsSt martinFrench polynesiaSt helenaSt barthelemyNew caledoniaPuerto ricoWallis & futunaFrench guianaGuernseyBritish indian ocean territoryMayotteSt pierre & miquelonAnguillaAmerican samoaFaroe islandsBermudaUs minor outlying islandsFrench southern territoriesBritish virgin islandsUs virgin islandsNetherlands antillesArubaAland islandsSouth georgiaBonaireBouvet islandCocos islandsCuracaoChristmas islandFalkland islandsHeard & mcdonald islandsIsle of manJerseyMacauNorthern marianasMontserratNorfolk islandPitcairn islandsJan mayenTokelauTurks & caicos islandsSvalbard`.split(/(?=[A-Z])/),

    E,                      // polygons for each country (array of strings, 2b + 1b per point)
    [...Array(52).keys()],  // questions not asked yet
    0,                      // how many bytes represent each item
    `#080`,                 // fill color
    `#123`,                 // stroke color
    0,                      // start byte for the path
    1,                      // name group size
    0,                      // position in name group
    8,                      // diststep
  ],

  // 4: deserts
  [
    `DESERT`,               // dataset name
    
    // names
    `SaharaColorado plateauArabian desertGobiGreat victoriaSimpsonAtacamaSyrian desertGreat sandy desertNamibChihuahuan desertKalahariPatagonian desertKarakumSonoranKyzylkumTaklamakanTharGibsonDasht-e margoRegistanMojaveDasht-e kavirDasht-e loot`.split(/(?=[A-Z])/),

    I,                      // polygons for each country (array of strings, 2b + 1b per point)
    [...Array(24).keys()],  // questions not asked yet
    0,                      // how many bytes represent each item
    `rgba(255,255,255,.2)`, // fill color
    0,                      // stroke color
    0,                      // start byte for the path
    1,                      // name group size
    0,                      // position in name group
    8,                      // diststep
  ],
  
  // 5: forests
  [
    `FOREST`,               // dataset name
    
    // names
    `Amazon rainforestSumatra rainforestTaigaGreat lakes st lawrenceSierra nevadaMiombo woodlandsCongo basinKinabaluSundarbansDaintree rainforestXishuangbannaBialowieza primeval forestBlack forestVirgin komi forestsLacandon jungleTongassBosawas biosphere reserveAtlantic forestValdivian rainforest`.split(/(?=[A-Z])/),

    L,                      // polygons for each country (array of strings, 2b + 1b per point)
    [...Array(19).keys()],  // questions not asked yet
    0,                      // how many bytes represent each item
    `rgba(0,0,0,.1)`,       // fill color
    0,                      // stroke color
    0,                      // start byte for the path
    1,                      // name group size
    0,                      // position in name group
    8,                      // diststep
  ],
  
  // 6: lakes
  [
    `LAKE`,                 // dataset name
    
    // names
    `SuperiorLemanMichiganTiticacaVictoriaGreat bear lakeMalawiGreat slave lakeNicaraguaLoch nessTaal lakeBaikalOntarioPinatuboHuronTanganyikaErieWinnipegLadogaBalkhashOnegaCrater lakeReed flute caveEmerald lakeMirror lakeSpotted lake`.split(/(?=[A-Z])/),

    G,                      // polygons for each country (array of strings, 2b + 1b per point)
    [...Array(26).keys()],  // questions not asked yet
    0,                      // how many bytes represent each item
    `#0af`,                 // fill color
    `#123`,                 // stroke color
    0,                      // start byte for the path
    1,                      // name group size
    0,                      // position in name group
    8,                      // diststep
  ],
  
  // 7: streams
  [
    `STREAM`,               // dataset name
    
    // names
    `AmazoneNileCongoNigerLoireZambezeIndusMississippiColoradoColumbiaUruguayYangtzeYellow riverXiUralDanubeRhinElbeMeuseRhoneSeineOrangeSenegalVoltaChariGambiaDraaBandamaTanaParanaYukonSao franciscoJubbaLimpopoRio grandeTocantinsOrinocoBrazosMackenzieMagdalenaFraserParnaibaSaint-laurentRio negroEssequiboLenaAmourMekongIenisseiObBrahmapoutreSalouenEuphratesAmou-dariaGangeSyr-dariaIrrawaddyKolymaTigrisIndiguirkaKouraGodavariKrishnaNarmadaRed riverAnadyrVolgaDnieperDonPechoraDniestrTagusVistuleDaugavaMurraySepik`.split(/(?=[A-Z])/),

    H,                      // polygons for each country (array of strings, 2b + 1b per point)
    [...Array(76).keys()],  // questions not asked yet
    0,                      // how many bytes represent each item
    0,                      // fill color
    `#0df`,                 // stroke color
    0,                      // start byte for the path
    1,                      // name group size
    0,                      // position in name group
    8,                      // diststep
  ],
  
  // 8: capitals            
  [                         
    `CAPITAL`,              // dataset name
    A,                      // names
    C,                      // polygons for each country (array of strings, the first 2b represent the capital)
    [...Array(199).keys()], // questions not asked yet
    2,                      // how many bytes represent each item
    0,                      // fill color
    0,                      // stroke color
    0,                      // start byte for the path
    3,                      // name group size
    2,                      // position in name group
    8,                      // diststep
  ],                        
  
  // 9: us capitals
  [
    `US CAPITAL`,           // dataset name
    B,                      // names
    D,                      // polygons for each country (array of strings, the first 2b represent the capital)
    [...Array(50).keys()],  // questions not asked yet
    2,                      // how many bytes represent each item
    0,                      // fill color
    0,                      // stroke color
    0,                      // start byte for the path
    2,                      // name group size
    1,                      // position in name group
    6,                      // diststep
  ],
  

  // 10: volcanoes
  [
    `VOLCANO`,              // dataset name
    
    // names
    `EtnaVesuviusPiton de la fournaiseMount peleeEyjafjallajokullSt helensKilaueaStromboliSanta mariaPinatuboYasurTaalAmbrymMerapiErta alePacayaErebusSakurajimaNyiragongoUlawunMauna loaGalerasKrakatoaTamboraNevado del ruiz`.split(/(?=[A-Z])/),

    J,                      // polygons for each country (array of strings, the first 2b represent the capital)
    [...Array(25).keys()],  // questions not asked yet
    2,                      // how many bytes represent each item
    0,                      // fill color
    0,                      // stroke color
    0,                      // start byte for the path
    1,                      // name group size
    0,                      // position in name group
    8,                      // diststep
  ],

  // 11: mountains
  [
    `MOUNTAIN`,             // dataset name
    
    // names
    `Mount everestK2AnnapurnaFujiKilimanjaroMont blancPopocatepetlOlympusBroad peakCookLhotseMakaluCho oyuDhaulagiriManasluNanga parbatGasherbrum iGasherbrum iiShishapangmaKangchenjungaDenaliKirkjufellFitz royHuaElbrusMatterhornEl capitanGrand tetonLicancaburTre cime de lavaredoBen nevisRainierKinabaluHuangKailashBanff`.split(/(?=[A-Z])/),

    K,                      // polygons for each country (array of strings, the first 2b represent the capital)
    [...Array(36).keys()],  // questions not asked yet
    2,                      // how many bytes represent each item
    0,                      // fill color
    0,                      // stroke color
    0,                      // start byte for the path
    1,                      // name group size
    0,                      // position in name group
    8,                      // diststep
  ],

  // 12: places
  [
    `PLACE`,                // dataset name
    
    // names
    `Cape canaveralChrist redeemerGreat wall of chinaSphinxEiffel towerPisa towerSagrada familiaBig benLiberty statueForbidden cityGiza pyramidsVersailles palaceAcropolisTrevi fountainKremlinAtomiumLascaux cavesMont st michelPiazza san marcoWashington dcGrand canyonMillau bridgeGibraltar rockEmpire state buildingHollywood signTimes squareLouvre museumWhite houseFlorence cathedralLas vegasMadrid palaceCentral parkSistine chapelPiazza del campoMachu picchuBurj al arab hotelSt peter basilicaCapitol hillLuxor templeGolden gate bridgeBurj khalifaAlcatrazEphesusManneken pisMount eden craterNorth capeSt basil cathedralVictoria fallsGreat buddha of kamakuraLotus templeColosseumAbu simbelPetronas twin towersYellowstoneNiagara fallsTaj mahalMeccaAuschwitzStonehengeMount rushmorePentagonCape of good hopeOpera houseParc guellPompeiiWaterlooEaster islandEvergladesCloud gateRialto bridgeWillis towerLittle mermaidTower bridgeBlue mosqueNevado mismiTable mountainMinaret of jamAngkor watNeuschwanstein castleAmritsar golden templeBesakih templeChichen itzaBran castleHagia sophiaUluruBrandenburg gateBlue domed churchCheyenne mountainKiyomizu-deraPetraTombouctouNull island`.split(/(?=[A-Z])/),
    
    F,                      // polygons for each country (array of strings, the first 2b represent the capital)
    [...Array(92).keys()],  // questions not asked yet
    2,                      // how many bytes represent each item
    0,                      // fill color
    0,                      // stroke color
    0,                      // start byte for the path
    1,                      // name group size
    0,                      // position in name group
    8,                      // diststep
  ],
  
  // 13: flags
  [
    `COUNTRY`,              // dataset name (not `flags` because the game will say `find this country:`)
    A,                      // names
    C,                      // polygons for each country (array of strings, the first 2b represent the capital)
    [...Array(199).keys()], // questions not asked yet
    0,                      // how many bytes represent each item
    0,                      // fill color
    0,                      // stroke color
    2,                      // start byte for the path
    3,                      // name group size
    0,                      // position in name group
    8,                      // diststep
  ]
],

c = a.getContext`2d`,                   // canvas context2d
flags = 1,                              // enable flags
scores = [],                            // scores for each question

/*

// Globals, only used for minification

questions,                              // total questions (chosen by player)
score,                                  // final score
random,                                 // random()
itemname,                               // current item name
error,                                  // current error
item,                                   // current item index
items,                                  // current list of questions
itemindex,                              // current item index
nameparts,                              // current item name parts
dataset,                                // current dataset
lastdataset,                            // previous dataset
ds,                                     // dataset being drawn
us,                                     // USA question
time,                                   // time to answer each question
interval,                               // interval to load the flags
tmp,                                    // array returned by traceitem(): [mindist, x, y]
timeout,                                // time out (when the player takes too long to answer)
x, y, tmpx, tmpy, x0, y0, dist,         // temp vars for polygon tracing
*/

timer = 0,                              // countdown (ms)
mode = 0,                               // 0 = highest score / 1 = endless
errorsum = 0,                           // error sum (in mode 1)
question = 0,                           // current question number
state = 0,                              // 0 = title screen

// FUNCTIONS
// =========

// Draw a screen
draw = e => {

  // Reset canvas
  a.width = 1020;
  
  // Black background except on map and feedback
  if(state != 3 && state != 4){
    c.fillStyle = `#123`;
    c.fillRect(0, 0, 1020, 1020);
  }

  // Title screen (0)
  if(!state){
    
    // Stars
    c.fillStyle = `#fff`;
    for(i = 999; i--;){
      c.beginPath();
      c.arc(Math.random() * 1020, Math.random() * 1020, Math.random(), 0, 7);
      c.fill(); 
    }
    
    // 2
    c.font = `600px i`;
    c.fillStyle = `#07d`;
    c.fillText(2, 690, 530);
    
    // Emoji earth
    c.font = `230px i`;
    c.fillText(`\u{1f30d}`, 225, 410);
    
    // GE ... QUIZ
    c.fillStyle = `#fff`;
    c.fillText(`GE     QUIZ`, 50, 415);
  }
  
  // Propose to load flags on Windows and Linux (6)
  else if(state == 6){

    c.font = `110px f`;
    
    c.fillText(`\u{1f1fa}\u{1f1f8}`, 450, 360);
  
    c.fillStyle = `#fff`;
    c.font = `110px i`;
    
    c.fillText(`Loading flags`, 200, 150);
    c.fillText(`\u25b8OK     \u25b8skip`, 210, 480);
    
    c.font = `40px i`;
    
    c.fillText(`Click OK when you see a flag below:`, 220, 220);
  }
  
  // Menu (1)
  else if(state == 1){
    
    c.fillStyle = `#fff`;
    c.font = `110px i`;
    
    c.fillText(`Game mode`, 60, 150);
    
    c.font = `70px i`;
    
    c.fillText(`\u25b8High score`, 50, 280);
    c.fillText(`\u25b8Endless`, 50, 460);
    
    c.font = `35px i`;
    
    c.fillText(`Answer 25 to 1000 questions and get a grade`, 110, 330);
    c.fillText(`Play until you reach 50,000km of errors`, 110, 510);

  }
  
  // High score submenu (7)
  else if(state == 7){
  
    c.fillStyle = `#fff`;
    
    c.font = `60px i`;
    
    c.fillText(`\u25b825 questions`, 50, 170);
    c.fillText(`\u25b850 questions`, 50, 300);
    c.fillText(`\u25b8100 questions`, 50, 430);
    
    c.fillText(`\u25b8250 questions`, 530, 170);
    c.fillText(`\u25b8500 questions`, 530, 300);
    c.fillText(`\u25b81000 questions`, 530, 430);
  }
  
  // Choose a question (2)
  else if(state == 2){
  
    // Pick a dataset
    // --------------
      
    // First 3 questions: country (1), capital (8), place (12), territory (3), sea (0)
    if(question < 5){
      lastdataset = dataset = [1,8,12,3,0][question];
    }

    // For all the other questions, the dataset is picked randomly
    else {
      dataset = lastdataset;
      
      // Try 999 times to pick another dataset than the previous one, then abandon and take the same
      for(i = 0; i < 999; i++){
      
        random = Math.random();
      
        // 30% chance to choose country, capital or place (10% each)
        if(random < .1) dataset = 1;
        else if(random < .2) dataset = 8;
        else if(random < .3) dataset = 12;
        
        // 70% chance to choose one of the 11 other datasets (or 10 if flags are disabled)
        else {
          
          // Flags: 70% / 11 = 6.4% for datasets 0 and 4-11
          // No flags: 70% / 10 = 7% for datasets 0 and 4-10
          dataset = (4 + (~~((random - .3) / (flags ? .064 : .07)))) % (flags ? 14 : 13);
        }

        // If we found a new dataset not empty: keep it
        // Also, avoid US capitals before question 20
        if(dataset != lastdataset && datasets[dataset][3].length && !(question < 20 && dataset == 9)){
          break;
        }
        
        // Else, take the previous one (it is for sure not empty but it was avoided until now)
        dataset = lastdataset;
      }
      
      // Save this dataset to avoid picking it again
      lastdataset = dataset;
    }
    
    // Debug
    //dataset = 12;
    
    items = datasets[dataset][3];
    
    // Pick a question
    // ---------------
    
    // Pick one of the first N questions not asked yet (N = number of questions asked)
    // This ensures a progressive difficulty
    // For the first 3 questions, pick between the first 30 (they're all easy, and it makes the games less repetitive)
    item = ~~(Math.random() * Math.min(question < 3 ? 30 : question, items.length)); 
    
    itemindex = items[item];
    
    // Save item's name
    itemname = 
      datasets[dataset][1] // names
      [datasets[dataset][8] * itemindex + datasets[dataset][9]] // name index
      .toUpperCase();

    // Remove that question from the array of available questions
    items.splice(item, 1);
    
    // Display everything
    // ------------------
    
    c.fillStyle = `#fff`;
    
    // question number
    c.font = `40px i`;
    c.fillText(`Question ` + (question + 1) + (!mode ? (`/` + questions) : ``), 30, 50);
    
    // Errors so far
    if(mode && errorsum){
      c.fillText(`Errors: ` + errorsum + `km`, 30, 100);
    }
    
    c.textAlign = `center`;
    c.font = `70px i`;
    
    // Find this ... :
    c.fillText(`FIND THIS ` + datasets[dataset][0] + `:`, 512, 280);
    
    // arrow
    c.fillText(`\u25b8`, 950, 550);
    
    // Question
    
    // Flag
    if(dataset == 13){
      c.font = `200px f`;
      c.fillText(itemname = String.fromCodePoint(0x1F1E6 + itemname.charCodeAt() - 65, 0x1F1E6 + itemname.charCodeAt(1) - 65), 512, 470);
    }
    
    // Name
    else {
      c.font = `99px i`;
      nameparts = itemname.match(/.{1,16}( |$)/g);
      
      c.fillText([nameparts[0]], 510, 400);
      c.fillText([nameparts[1]], 510, 500);
      
    }
    
    
    // If no question left or 50000km attained in mode 1: go to score screen
    if(question >= questions || !items.length || errorsum > 50000){
      state = 5;
      draw();
      //return;
    }
  }
  
  // Map (3)
  else if(state == 3){
  
    // Detect US question
    us = dataset == 2 || dataset == 9;
    
    // Trace datasets 1-7 (scaled if US state or US capital)
    for(ds = 1; ds < 8; ds++){
    
      // US polygons are 1.5px more to the left
      //extraxoffset = ds == 2 ? 0 : -1.5;
      
      // Trace
      // Trace in black every 10 questions
      trace(ds, us ? 3.9 : 1, us ? -254 : -4, us ? -350 : 0, (question % 9 > 7 ? "#123" : 0), (question % 9 > 7 ? "#123" : 0) );
    }
    
    // Repeat the question
    c.fillStyle = `#123`;
    c.fillRect(0, 0, 1020, 60);
    
    c.fillStyle = `#fff`;
    c.font = `40px i,f`;
    c.fillText(datasets[dataset][0] + `: ` + itemname, 10, 45);
    
    timer = 19998;
    timeout = 0;

  }
  
  // Feedback (4)
  else if(state == 4){

    // If the item is a sea (dataset 0), trace it highlighted in yellow before the rest of the map
    if(!dataset){
      tmp = tracesea(M[itemindex]);
    }
    
    // Trace the datasets 1-7
    for(ds = 1; ds < 8; ds++){
      
      // Trace
      trace(ds, us ? 3.9 : 1, us ? -254 : -4, us ? -350 : 0, (question % 9 > 7 ? "#123" : 0), (question % 9 > 7 ? "#123" : 0));
    }
    
    // If the item is a polygon, trace it highlighted on top of the map
    if(dataset){
    
      // Special case if the country is USA: draw the USA set
      if((dataset == 1 || dataset == 13) && itemindex == 72){
        tmp = trace(2, 1, -4, 0, "#ff0", "#db0");
      }
      
      else {
      
        tmp = traceitem(
          datasets[dataset][2][itemindex],// polygon
          datasets[dataset][7],           // start byte
          datasets[dataset][4],           // bytes to draw
          datasets[dataset][10],          // diststep
          dataset == 7 ? 0 : `#ff0`,      // fill (except for streams)
          `#db0`,                         // stroke
          us ? 3.9 : 1,                   // scale
          us ? -254 : -4,                 // x offset
          us ? -350 : 0,                  // y offset
          5,                              // line width
        );
      }
    }
    
    c.fillStyle = `#123`;
    c.font = `80px i`;
    c.strokeStyle = `#fff`;
    c.lineWidth = 1;
  
    // Timeout
    if(timeout){
      c.fillText(`Time out!`, 400, 530);
      c.strokeText(`Time out!`, 400, 530);
      time = 100;
    }
    
    // Perfect
    else if(tmp[0] < 5){
      c.fillText(`Perfect!`, 400, 530);
      c.strokeText(`Perfect!`, 400, 530);
    }
    
    // Error
    else{
    
      // Scale: 100px = 3000km
      // 1px = 30km      
      error = ~~(tmp[0] * .3) * 100;
      if(mode){
        errorsum += error;
      }
      
      c.fillText(error + `km away!`, 300, 530);
      c.strokeText(error + `km away!`, 300, 530);
    }
    
    // Trace the error distance (if any), including offscreen (+/- 1020px)
    if(tmp[0] > 4 && !timeout){
      c.beginPath();
      c.fillStyle = `red`;
      c.arc(X, Y, 9, 0, 7);
      c.fill();
      c.beginPath();
      c.setLineDash([15, 5]);
      c.strokeStyle = `red`;
      c.lineWidth = 5;
      c.moveTo(X, Y);
      c.lineTo(tmp[1],tmp[2]);
      
      c.moveTo(X - 1020, Y);
      c.lineTo(tmp[1]-1020,tmp[2]);
      
      c.moveTo(X + 1020, Y);
      c.lineTo(tmp[1] + 1020, tmp[2]);
      
      c.stroke();
      c.setLineDash([]);
    }
    
    
    
    // Repeat the question + the country if the question was a capital or a flag
    c.fillStyle = `#123`;
    c.fillRect(0, 0, 1020, 60);
    
    c.fillStyle = `#fff`;
    c.font = `40px i,f`;
    c.fillText(datasets[dataset][0] + `: ` + itemname + (dataset == 8 || dataset == 13 ? ` (` + A[itemindex * 3 + 1] + `)` : dataset == 9 ? ` (` + B[itemindex * 2] + `)` : ``).toUpperCase(), 10, 45);
    
    // Score for each question: 100 - time (in seconds) - (error in km) / 50
    scores[question] = Math.max(0, 100 - time - ~~(error / 50));
    
    timer = 3300;
    
  }
  
  // Score (5)
  else if(state == 5){
    
    // Min errors
    if(mode){
      score = question + ` question` + (question > 1 ? "s" : "");
    }
    
    // Max score
    else {
      score = ~~(scores.reduce((a,b)=>a+b) / scores.length) + `%`;
    }
    
    c.fillStyle = `#fff`;
    c.textAlign = `center`;
    c.font = `90px i`;
    
    c.fillText(`Score: ` + score, 510, 250);

    c.font = `40px i`;
    c.fillText(`\u25b8share`, 510, 400);
    c.fillText(`\u25b8replay`, 510, 500);

  }
},


// Convert a latin-1 char to int
latin2int = (i,J) =>
  i ? (6E4 < (J = i.charCodeAt()) ? 0 : 255 < J ? `ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½`.indexOf(i) + 128 : J) : 0,

// Draw an item (point / polygon)
// and return an array containing the distance and x/y coordinates of the point that's the closest to the click coordinates (X/Y)
traceitem = (polygon, startbyte, bytes, diststep, fill, stroke, scale, xoffset, yoffset, linewidth, ret = [0], mindist = 1e5, j, k, J, A, D) => {
  
  // Separate the islands of the polygon (using char U+127)
  polygon = polygon.slice(startbyte).split``;
  
  // For each island (or just the first island if a number of bytes is specified)
  for(k = bytes ? 1 : polygon.length; k--;){
    
    // For each point of the island (or the number of bytes specified)
    for(j = 0; j < (bytes ? bytes : polygon[k].length); j++){

      // Continue the path with a distance and an angle encoded together in 1 char
      if(j){
      
        J = latin2int(polygon[k][j]);
        A = -((J >> 3) - 1) * Math.PI / 8,
        D = (J & 7) * diststep + diststep,
        x = Math.floor(x + D * Math.cos(A))
        y = Math.floor(y + D * Math.sin(A))
        c.lineTo(tmpx = x / 2 * scale + xoffset, tmpy = y / 2 * scale + yoffset + 65);

        // Save the center if it's the closest to the click coordinates
        dist = Math.hypot(X - tmpx, Y - tmpy);
        
        if(dist < mindist){
          ret = [mindist = dist, tmpx, tmpy];
        }
        
        // Also, try offscreen paths
        if(scale == 1){
          dist = Math.hypot(X - (tmpx - 1020), Y - tmpy);
          if(dist < mindist){
            ret = [mindist = dist, tmpx - 1020, tmpy];
          }
          
          dist = Math.hypot(X - (tmpx + 1020), Y - tmpy);
          if(dist < mindist){
            ret = [mindist = dist, tmpx + 1020, tmpy];
          }
        }
        
      }
      
      // Begin the path with the start coordinates (X/Y, encoded in 1 char each)
      else {
        c.beginPath();
        x0 = x = (latin2int(polygon[k][j]) * diststep);
        y0 = y = (latin2int(polygon[k][j + 1]) * diststep / 2);
        c.moveTo(tmpx = x / 2 * scale + xoffset, tmpy = y / 2 * scale + yoffset + 65);
        
        // Save the point if it's the closest to the click coordinates
        dist = Math.hypot(X - tmpx, Y - tmpy);
        if(dist < mindist){
          ret = [mindist = dist, tmpx, tmpy];
        }
        
        // Also, try offscreen polygons (except for US) to see if they're closer
        if(scale == 1){
          dist = Math.hypot(X - (tmpx - 1020), Y - tmpy);
          if(dist < mindist){
            ret = [mindist = dist, tmpx - 1020, tmpy];
          }
          
          dist = Math.hypot(X - (tmpx + 1020), Y - tmpy);
          if(dist < mindist){
            ret = [mindist = dist, tmpx + 1020, tmpy];
          }
        }
        
        // Trace a little black square at the start coordinates, to make the little islands visible
        c.fillStyle = stroke;
        if(stroke && fill){
          c.fillRect(x / 2 * scale + xoffset, y / 2 * scale + yoffset + 65, 1, 1);
        }
        
        // Highlight (linewidth = 5) if the target is a point: circle the point in yellow
        if(linewidth == 5 && ((polygon.length == 1 && polygon[0].length < 5) || bytes == 2)){
          c.arc(x/2 * scale + xoffset, y/2 * scale + yoffset + 65, 8, 0, 7);
        }
        
        j++;
      }
    }
    
    // If the polygon is filled (i.e. not a stream), close the path
    if(fill){
      c.lineTo(x0/2 * scale + xoffset, y0/2 * scale + yoffset + 65);
    }
    
    // Stroke the path (0.5px wide for the streams, 5px if highlighted);
    c.strokeStyle = stroke;
    c.lineWidth = linewidth == 5 ? 5 : fill ? scale > 1 ? 4 : linewidth : .5;
    if(stroke){
      c.stroke();
    }
    
    // Fill the path (poles are colored in white except during highlight)
    if(fill){
      c.fillStyle = (linewidth < 5 && (question % 9 < 8) && (y0 < 80 || y0 > 900)) ? "#fff" : fill;
      c.fill();
    }
    
    // Check if the last click was inside the polygon
    if(c.isPointInPath(X, Y)){
      ret = [mindist = 0];
    }
  }
  
  // Adjust the error distance according to the scale
  ret[0] /= scale;
  
  return ret;
},

tracesea = (sea, mindist = 1e5, r, ret) => {
  x = latin2int(sea[0]) * 16;
  y = latin2int(sea[1]) * 16 / 2;
  r = latin2int(sea[2]) * 16;
  c.beginPath();
  c.arc(tmpx = x / 2, tmpy = y / 2 + 65, r / 2, 0, 7);
  c.arc(x / 2 - 1020, y / 2 + 65, r / 2, 0, 7);
  c.arc(x /2 + 1020, y / 2 + 65, r / 2, 0, 7);
  
  // Save the center if it's the closest to the click coordinates
  dist = Math.hypot(X - tmpx, Y - tmpy);
  if(dist < mindist){
    ret = [mindist = dist - r/2, tmpx, tmpy];
  }
  
  // Also, try offscreen seas
  dist = Math.hypot(X - (tmpx - 1020), Y - tmpy);
  if(dist < mindist){
    ret = [mindist = dist - r/2, tmpx - 1020, tmpy];
  }
  
  dist = Math.hypot(X - (tmpx + 1020), Y - tmpy);
  if(dist < mindist){
    ret = [mindist = dist - r/2, tmpx + 1020, tmpy];
  }
  
  c.fillStyle = `#ff0`;
  c.fill();
  if(c.isPointInPath(X,Y)){
    ret = [mindist = 0];
  }
  
  return ret;
},

// Draw a dataset
trace = (ds, scale, xoffset, yoffset, fill, stroke, mindist = 1e5, tmp, ret) => {

  ds = datasets[ds];
  
  // Trace each item with the right params
  for(i in ds[2]){
    tmp = traceitem(ds[2][i], ds[7], ds[4], ds[10], fill || ds[5], stroke || ds[6], scale, xoffset, yoffset, 2);
    if(tmp[0] < mindist){
      ret = tmp;
      mindist = tmp[0];
    }
  }
  return ret;
},


// Music
music = (audio, gain, note, notes, oscillator) => {
audio = new AudioContext;
gain = audio.createGain();
for(note in notes = `










cccc\r
ccc










cccc
ccc


\r
ccc
c\rcc`){
  oscillator = audio.createOscillator(),
  oscillator.connect(gain),
  gain.connect(audio.destination);
  oscillator.start(note * .2);
  oscillator.frequency.setValueAtTime(415 * 1.06 ** (13 - notes.charCodeAt(note)), note * .2),
  gain.gain.setValueAtTime(.03, note * .2); 
  gain.gain.setTargetAtTime(.001, note * .2 + .18, .005)
  oscillator.stop(note * .2 + .19);
}
setTimeout(music, 30500);
};
  
// EVENTS
// ======
  
// Mouseup, touchend
onmouseup = e => {

  //console.log(state);

  // Convert pointer coords to canvas intrinsic coords (X, Y).
  // Measure canvas size on state
  w = a.offsetWidth;
  
  // Mobile
  if(e.changedTouches){
    X = e.changedTouches[0].pageX * 1020 / w;
    Y = e.changedTouches[0].pageY * 1020 / w;
  }
  
  // Desktop
  else{
    X = e.pageX * 1020 / w;
    Y = e.pageY * 1020 / w;
  }
  
  // On title screen (0)
  if(!state){

    // detect OS with bad flag support (Win / Linux)
    state = navigator.userAgent.match(/Mac|iO|An/) ? 1 : 6;
  }
  
  // On flags screen (6)
  else if(state == 6){
  
    // Skip
    if(X > 510){
      flags = 0;
    }
    
    state = 1;
  }
  
  // On mode screen (1)
  else if(state == 1){
  
    // Least errors
    if(Y > 370) {
      questions = 1e5;
      mode = 1;
      state = 2;
    }
    
    // High score
    else {
      state = 7;
    }
  }
  
  // On High score submenu (7)
  else if(state == 7){
    if(Y > 350){
      questions = 100;
    }
    else if(Y > 210){
      questions = 50;
    }
    else{
      questions = 25;
    }
    
    if(X > 500){
      questions *= 10;
    }
    
    state = 2;
  }
  
  // On question screen (2)
  else if(state == 2){
    
    // Go to map
    state = 3;
  }
  
  // On map (3)
  else if(state == 3){
  
    // Stop timer, save time elapsed in seconds
    time = 20 - timer / 1000;
    
    // Go to feedback
    state = 4;
  }
  
  // On feedback (4)
  else if(state == 4){ // && timer > 999
  
    // Go to next question
    question++;
    
    state = 2;
  }
  
  // On score screen (5)
  else if(state == 5){
    
    // Share / reload
    location = Y < 430 ? "//xem.github.io/geoquiz2/s/#"+[score,mode,questions] : location;
    
  }
  
  draw();
  
};


// INIT
// ====

// Remove Kosovo flag, because it can't be displayed properly on many browsers, even with a Web font.
datasets[13][3].splice(102, 1);

// Draw title screen
draw();

// MUSIC
// =====
music();

//window.dat = datasets;

// GAME LOOP (100ms)
setInterval(e => {
  
  if(timer){
    timer -= 33;
  }

  // Redraw flags screen every 100ms to draw the flag when the font is finally loaded 
  if(state == 6){
    draw();
  }
  
  // Time limit on map screen (20s)
  else if (state == 3){
    c.beginPath();
    c.fillStyle = "#ff0";
    c.fillRect(0, 58, 1020 - 1020 * timer / 20000, 4);
    if(!timer){
      state = 4;
      timeout = 1;
      draw();
    }
  }
  
  // Auto skip on feedback screen (2s)
  else if(state == 4){
    if(!timer){
      state = 2;
      question++;
      draw();
    }
  }
}, 33);

}

</script>
<style>

/* The font "f" uses the Emoji fonts Noto Color emoji and Twemoji (for Windows) */
@font-face{font-family:f;src:url(//xem.github.io/geoquiz2/n.ttf),url(//xem.github.io/geoquiz2/t.ttf)}

/* The font "i" uses the local font Impact and a fallback for old OS that may not have it */
@font-face{font-family:i;src:local(impact),url(//xem.github.io/geoquiz2/i.ttf)}

/* Global style */
*{margin:0;background:#123;cursor:crosshair;width:100%;overflow:hidden;max-width:177vh;font-family:i}

/* Canvas radial background */
#a{background:radial-gradient(#7DF 50%,#0af)}
